7b1aa134a8bc4a376296bcfac5c3463aef2b7572
mjpclab@@object-hierarchy-access
diff --git a/built/setup.js b/built/setup.js
index 21cbf43..940f3a7 100644
--- a/built/setup.js
+++ b/built/setup.js
@@ -1,12 +1,17 @@
 import { normalizeDescriptor } from './utility/setup';
 import { getNonEmptyPropName } from './utility/common';
+const propProto = '__proto__';
 function generate(target, hierarchies, forceOverride) {
     let current = target;
     hierarchies.forEach(info => {
         const descriptor = normalizeDescriptor(info);
         const { value, type, create, override, created, skipped, got } = descriptor;
         const name = getNonEmptyPropName(current, descriptor);
-        if (forceOverride || override || !current[name] || typeof current[name] !== 'object') {
+        if (forceOverride ||
+            override ||
+            !current[name] ||
+            typeof current[name] !== 'object' ||
+            (name === propProto && current[name] === Object.prototype)) {
             const obj = value ? value :
                 type ? new type() :
                     create ? create.call(current, current, name) :
diff --git a/dist/index.esm.js b/dist/index.esm.js
index 021a1d8..f5bc360 100644
--- a/dist/index.esm.js
+++ b/dist/index.esm.js
@@ -73,13 +73,18 @@ function getPropNames(current, descriptor) {
     return getOwnEnumerablePropKeys(current);
 }
 
+const propProto = '__proto__';
 function generate(target, hierarchies, forceOverride) {
     let current = target;
     hierarchies.forEach(info => {
         const descriptor = normalizeDescriptor(info);
         const { value, type, create, override, created, skipped, got } = descriptor;
         const name = getNonEmptyPropName(current, descriptor);
-        if (forceOverride || override || !current[name] || typeof current[name] !== 'object') {
+        if (forceOverride ||
+            override ||
+            !current[name] ||
+            typeof current[name] !== 'object' ||
+            (name === propProto && current[name] === Object.prototype)) {
             const obj = value ? value :
                 type ? new type() :
                     create ? create.call(current, current, name) :
diff --git a/dist/index.js b/dist/index.js
index d62e86c..4c87124 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -79,13 +79,18 @@
 	    return getOwnEnumerablePropKeys(current);
 	}
 
+	var propProto = '__proto__';
 	function generate(target, hierarchies, forceOverride) {
 	    var current = target;
 	    hierarchies.forEach(function (info) {
 	        var descriptor = normalizeDescriptor(info);
 	        var value = descriptor.value, type = descriptor.type, create = descriptor.create, override = descriptor.override, created = descriptor.created, skipped = descriptor.skipped, got = descriptor.got;
 	        var name = getNonEmptyPropName(current, descriptor);
-	        if (forceOverride || override || !current[name] || typeof current[name] !== 'object') {
+	        if (forceOverride ||
+	            override ||
+	            !current[name] ||
+	            typeof current[name] !== 'object' ||
+	            (name === propProto && current[name] === Object.prototype)) {
 	            var obj = value ? value :
 	                type ? new type() :
 	                    create ? create.call(current, current, name) :
diff --git a/dist/index.min.js b/dist/index.min.js
index 0cb0cb9..6b1eda4 100644
--- a/dist/index.min.js
+++ b/dist/index.min.js
@@ -1 +1 @@
-!function(r,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((r="undefined"!=typeof globalThis?globalThis:r||self).ObjectHierarchyAccess={})}(this,(function(r){"use strict";function e(r){return Array.isArray(r)||r instanceof Array}function n(r){return"object"==typeof r&&null!==r}function t(r){var e=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r).filter((function(e){var n=Object.getOwnPropertyDescriptor(r,e);return n&&n.enumerable}));n.length&&e.push.apply(e,n)}return e}function a(r){return e(r)?[]:n(r)?{}:r}function u(r,e){var n=e.name,t=e.getName;return n!==undefined?n:t?t.call(r,r):void 0}function o(r,n){var a=n.names,u=n.getNames;if(a!==undefined)return e(a)?a:[a];if(u){var o=u.call(r,r);if(o!==undefined)return e(o)?o:[o]}return t(r)}function f(r,e,n){var t=r;return e.forEach((function(r){var e=function(r){return"object"==typeof r&&null!==r?r:"function"==typeof r?{getName:r,value:{}}:{name:r,value:{}}}(r),a=e.value,o=e.type,f=e.create,i=e.override,c=e.created,l=e.skipped,p=e.got,v=function(r,e){var n=u(r,e);return n!==undefined?n:"undefined"}(t,e);if(n||i||!t[v]||"object"!=typeof t[v]){var h=a||(o?new o:f?f.call(t,t,v):{});t[v]=h,c&&c.call(t,t,v,h)}else l&&l.call(t,t,v,t[v]);var s=t;t=t[v],p&&p.call(s,s,v,t)})),t}function i(r,e){return f(r,e)}function c(r,e){var n=f(r,e.slice(0,-1));return{current:n,last:f(n,e.slice(-1),!0)}}function l(r){var e=r[r.length-1],n=Array.prototype.concat.apply([],r.slice(0,-1));return{hierarchies:n.slice(0,-1),prop:n[n.length-1],value:e}}function p(r){return Array.prototype.concat.apply([],r)}function v(r){for(var e=[],n=1;n=i.length)){var c=new i[a[0]],l=function e(r,n,u){if(u<=o)t(n).forEach((function(t){var a=u+1;d(n,t)&&e(r.concat(t),n[t],a)}));else{var l=a.map((function(e,t){return t=0;i--){var c=f[i],l=u.call(c.parent,c.parent,c.name,c.current);if(!1===l)break}}},Object.defineProperty(r,"__esModule",{value:!0})}));
+!function(r,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((r="undefined"!=typeof globalThis?globalThis:r||self).ObjectHierarchyAccess={})}(this,(function(r){"use strict";function e(r){return Array.isArray(r)||r instanceof Array}function n(r){return"object"==typeof r&&null!==r}function t(r){var e=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r).filter((function(e){var n=Object.getOwnPropertyDescriptor(r,e);return n&&n.enumerable}));n.length&&e.push.apply(e,n)}return e}function a(r){return e(r)?[]:n(r)?{}:r}function u(r,e){var n=e.name,t=e.getName;return n!==undefined?n:t?t.call(r,r):void 0}function o(r,n){var a=n.names,u=n.getNames;if(a!==undefined)return e(a)?a:[a];if(u){var o=u.call(r,r);if(o!==undefined)return e(o)?o:[o]}return t(r)}function f(r,e,n){var t=r;return e.forEach((function(r){var e=function(r){return"object"==typeof r&&null!==r?r:"function"==typeof r?{getName:r,value:{}}:{name:r,value:{}}}(r),a=e.value,o=e.type,f=e.create,c=e.override,i=e.created,l=e.skipped,p=e.got,v=function(r,e){var n=u(r,e);return n!==undefined?n:"undefined"}(t,e);if(n||c||!t[v]||"object"!=typeof t[v]||"__proto__"===v&&t[v]===Object.prototype){var h=a||(o?new o:f?f.call(t,t,v):{});t[v]=h,i&&i.call(t,t,v,h)}else l&&l.call(t,t,v,t[v]);var s=t;t=t[v],p&&p.call(s,s,v,t)})),t}function c(r,e){return f(r,e)}function i(r,e){var n=f(r,e.slice(0,-1));return{current:n,last:f(n,e.slice(-1),!0)}}function l(r){var e=r[r.length-1],n=Array.prototype.concat.apply([],r.slice(0,-1));return{hierarchies:n.slice(0,-1),prop:n[n.length-1],value:e}}function p(r){return Array.prototype.concat.apply([],r)}function v(r){for(var e=[],n=1;n=c.length)){var i=new c[a[0]],l=function e(r,n,u){if(u<=o)t(n).forEach((function(t){var a=u+1;d(n,t)&&e(r.concat(t),n[t],a)}));else{var l=a.map((function(e,t){return t=0;c--){var i=f[c],l=u.call(i.parent,i.parent,i.name,i.current);if(!1===l)break}}},Object.defineProperty(r,"__esModule",{value:!0})}));
diff --git a/src/setup.ts b/src/setup.ts
index 7432c0f..42fe536 100644
--- a/src/setup.ts
+++ b/src/setup.ts
@@ -2,6 +2,8 @@ import type {SetupPropParam} from './type';
 import {normalizeDescriptor} from './utility/setup';
 import {getNonEmptyPropName} from './utility/common';
 
+const propProto = '__proto__';
+
 function generate(
 	target: any,
 	hierarchies: SetupPropParam[],
@@ -13,7 +15,13 @@ function generate(
 		const {value, type, create, override, created, skipped, got} = descriptor;
 
 		const name = getNonEmptyPropName(current, descriptor);
-		if (forceOverride || override || !current[name] || typeof current[name] !== 'object') {
+		if (
+			forceOverride ||
+			override ||
+			!current[name] ||
+			typeof current[name] !== 'object' ||
+			(name === propProto && current[name] === Object.prototype)
+		) {
 			const obj = value ? value :
 				type ? new type() :
 					create ? create.call(current, current, name) :
diff --git a/test/set/7-no-proto-polution.js b/test/set/7-no-proto-polution.js
new file mode 100644
index 0000000..0894eb7
--- /dev/null
+++ b/test/set/7-no-proto-polution.js
@@ -0,0 +1,9 @@
+const assert = require('assert').strict;
+const {set} = require('../../');
+
+const obj1 = {};
+const obj2 = {};
+set(obj1, '__proto__', 'admin', true);
+assert.notEqual(obj1.__proto__, Object.prototype);
+assert.equal(obj1.__proto__.admin, true);
+assert.strictEqual(obj2.admin, undefined);
diff --git a/test/set/index.js b/test/set/index.js
index 1b1cf63..6cf5072 100644
--- a/test/set/index.js
+++ b/test/set/index.js
@@ -4,3 +4,4 @@ require('./3-symbol-property');
 require('./4-array-params');
 require('./5-array-value');
 require('./6-option-params');
+require('./7-no-proto-polution');
