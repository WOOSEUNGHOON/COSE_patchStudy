061addfb9a9e932a970e5fcb913d020038e65667
peerigon@@angular-expressions
diff --git a/.editorconfig b/.editorconfig
new file mode 100644
index 0000000..1f62f55
--- /dev/null
+++ b/.editorconfig
@@ -0,0 +1,13 @@
+root = true
+
+[*]
+end_of_line = lf
+insert_final_newline = true
+
+[*.js]
+charset = utf-8
+indent_style = tab
+
+[{.travis.yml,package.json}]
+indent_style = space
+indent_size = 2
diff --git a/.eslintignore b/.eslintignore
index 594eb24..3c3629e 100644
--- a/.eslintignore
+++ b/.eslintignore
@@ -1,2 +1 @@
 node_modules
-lib/parse.js
\ No newline at end of file
diff --git a/.eslintrc b/.eslintrc
index d615df1..b487d3c 100644
--- a/.eslintrc
+++ b/.eslintrc
@@ -1,8 +1,187 @@
 {
-    "extends": "peerigon/es5",
-    "root": true,
-    "env": {
-        "node": true,
-        "browser": true
-    }
+  "parserOptions" : {
+    "ecmaVersion": 7
+  },
+  "plugins": [],
+  "globals":{
+    "Promise": true,
+    "JQLite": true,
+    "JQLitePrototype": true,
+    "ArrayBuffer": true
+  },
+  "env": {
+    "node": true,
+    "browser": true,
+    "mocha": true
+  },
+  "rules": {
+    "accessor-pairs": 2,
+    "array-bracket-spacing": [2, "never"],
+    "arrow-parens": 0,
+    "arrow-spacing": [2, {"before": true, "after": true}],
+    "block-scoped-var": 2,
+    "block-spacing": [2, "always"],
+    "brace-style": 0,
+    "callback-return": 2,
+    "camelcase": [0 , {"properties": "never"}],
+    "comma-dangle": [0 , "always-multiline"],
+    "comma-spacing": [2, {"before": false, "after": true}],
+    "comma-style": [2, "last"],
+    "complexity": [2, 10],
+    "computed-property-spacing": [2, "never"],
+    "consistent-return": 0,
+    "consistent-this": [2, "self"],
+    "constructor-super": 2,
+    "curly": [2, "all"],
+    "default-case": 0,
+    "dot-location": [2, "property"],
+    "dot-notation": 2,
+    "eol-last": 2,
+    "eqeqeq": [2, "smart"],
+    "func-names": 0,
+    "func-style": [2, "declaration"],
+    "generator-star-spacing": [2, {"before": false, "after": true}],
+    "global-require": 0,
+    "guard-for-in": 2,
+    "handle-callback-err": 2,
+    "id-length": 0,
+    "id-match": 0,
+    "init-declarations": 0,
+    "key-spacing": [2, {"beforeColon": false, "afterColon": true, "mode": "strict"}],
+    "linebreak-style": 0,
+    "lines-around-comment": 0,
+    "max-nested-callbacks": 0,
+    "new-cap": [2, {
+      "newIsCapExceptions": ["Boom.badRequest", "Boom.forbidden", "Boom.unauthorized", "Boom.wrap"],
+      "capIsNewExceptions": ["squeeze.Squeeze"]
+    }],
+    "new-parens": 2,
+    "newline-after-var": 0,
+    "no-alert": 2,
+    "no-array-constructor": 2,
+    "no-caller": 2,
+    "no-catch-shadow": 0,
+    "no-class-assign": 2,
+    "no-console": 2,
+    "no-const-assign": 2,
+    "no-constant-condition": [2, {"checkLoops": false}],
+    "no-continue": 0,
+    "no-control-regex": 0,
+    "no-debugger": 2,
+    "no-delete-var": 2,
+    "no-div-regex": 2,
+    "no-dupe-args": 2,
+    "no-dupe-class-members": 2,
+    "no-dupe-keys": 2,
+    "no-duplicate-case": 2,
+    "no-else-return": 2,
+    "no-empty": 2,
+    "no-empty-character-class": 2,
+    "no-eval": 2,
+    "no-ex-assign": 2,
+    "no-extend-native": 2,
+    "no-extra-bind": 2,
+    "no-extra-boolean-cast": 2,
+    "no-extra-parens": [2, "functions"],
+    "no-extra-semi": 2,
+    "no-fallthrough": 2,
+    "no-floating-decimal": 2,
+    "no-func-assign": 2,
+    "no-implicit-coercion": 0,
+    "no-implied-eval": 2,
+    "no-inline-comments": 0,
+    "no-inner-declarations": 2,
+    "no-invalid-regexp": 2,
+    "no-irregular-whitespace": 2,
+    "no-iterator": 2,
+    "no-label-var": 2,
+    "no-labels": 0,
+    "no-lone-blocks": 2,
+    "no-lonely-if": 2,
+    "no-loop-func": 2,
+    "no-mixed-requires": 2,
+    "no-mixed-spaces-and-tabs": 0,
+    "no-multi-spaces": 2,
+    "no-multi-str": 2,
+    "no-multiple-empty-lines": [2, {"max": 1}],
+    "no-native-reassign": 2,
+    "no-negated-in-lhs": 2,
+    "no-new": 2,
+    "no-new-func": 2,
+    "no-new-object": 2,
+    "no-new-require": 2,
+    "no-new-wrappers": 2,
+    "no-obj-calls": 2,
+    "no-octal": 2,
+    "no-octal-escape": 2,
+    "no-param-reassign": 0,
+    "no-path-concat": 2,
+    "no-process-env": 2,
+    "no-process-exit": 2,
+    "no-proto": 2,
+    "no-redeclare": 2,
+    "no-regex-spaces": 2,
+    "no-restricted-modules": 0,
+    "no-restricted-syntax": 0,
+    "no-return-assign": 0,
+    "no-script-url": 2,
+    "no-self-compare": 2,
+    "no-sequences": 2,
+    "no-shadow": 0,
+    "no-shadow-restricted-names": 2,
+    "no-spaced-func": 2,
+    "no-sparse-arrays": 2,
+    "no-ternary": 0,
+    "no-this-before-super": 2,
+    "no-throw-literal": 2,
+    "no-trailing-spaces": 2,
+    "no-undef": 2,
+    "no-undef-init": 0,
+    "no-undefined": 0,
+    "no-underscore-dangle": 0,
+    "no-unexpected-multiline": 2,
+    "no-unneeded-ternary": 2,
+    "no-unreachable": 2,
+    "no-unused-expressions": 2,
+    "no-unused-vars": 2,
+    "no-use-before-define": [2, "nofunc"],
+    "no-useless-call": 2,
+    "no-useless-concat": 2,
+    "no-var": 0,
+    "no-void": 2,
+    "no-warning-comments": [2, {"terms": ["todo", "fixme"], "location": "anywhere"}],
+    "no-with": 2,
+    "object-curly-spacing": 0,
+    "object-shorthand": 0,
+    "one-var": 0,
+    "operator-assignment": [0, "always"],
+    "operator-linebreak": 0,
+    "padded-blocks": [2, "never"],
+    "prefer-arrow-callback": 0,
+    "prefer-const": 0,
+    "prefer-destructuring": [0, {
+       "AssignmentExpression": {
+        "array": true,
+        "object": false
+      }
+    }],
+    "prefer-reflect": 0,
+    "prefer-spread": 0,
+    "prefer-template": 0,
+    "quotes": [2, "double", {"avoidEscape":true}],
+    "quote-props": [2, "as-needed"],
+    "radix": 2,
+    "require-jsdoc": 0,
+    "require-yield": 2,
+    "semi": [2, "always"],
+    "semi-spacing": [2, {"before": false, "after": true}],
+    "sort-vars": 0,
+    "use-isnan": 2,
+    "valid-jsdoc": 0,
+    "valid-typeof": 2,
+    "vars-on-top": 0,
+    "wrap-iife": [2, "inside"],
+    "wrap-regex": 0,
+    "yoda": [2, "never"]
+  }
 }
diff --git a/README.md b/README.md
index 0818d3d..eb98242 100644
--- a/README.md
+++ b/README.md
@@ -1,5 +1,6 @@
-angular-expressions
-===================
+**A security vulnerability has been found that affects all versions before 1.0.1. Please read this advisory https://github.com/peerigon/angular-expressions/security/advisories/GHSA-hxhm-96pp-2m43 for more information.**
+
+# angular-expressions
 
 **[angular's nicest part](https://github.com/angular/angular.js/blob/6b049c74ccc9ee19688bb9bbe504c300e61776dc/src/ng/parse.js) extracted as a standalone module for the browser and node.**
 
@@ -38,16 +39,13 @@ Check out [their readme](http://docs.angularjs.org/guide/expression) for further
 
 
 
-Setup
------
+## Setup
 
 [![npm status](https://nodei.co/npm/angular-expressions.svg?downloads=true&stars=true&downloadRank=true)](https://npmjs.org/package/angular-expressions)
 
-
 
 
-Filters
--------
+## Filters
 
 Angular provides a mechanism to define filters on expressions:
 
@@ -62,25 +60,24 @@ Arguments are evaluated against the scope:
 
 ```javascript
 expressions.filters.currency = (input, currency, digits) => {
-    input = input.toFixed(digits);
+  input = input.toFixed(digits);
 
-    if (currency === "EUR") {
-        return input + "€";
-    } else {
-        return input + "$";
-    }
+  if (currency === "EUR") {
+    return input + "€";
+  } else {
+    return input + "$";
+  }
 };
 
 expr = expressions.compile("1.2345 | currency:selectedCurrency:2");
 expr({
-    selectedCurrency: "EUR"
+  selectedCurrency: "EUR"
 }); // returns '1.23€'
 ```
 
 
 
-API
-----
+## API
 
 ### exports
 
@@ -104,9 +101,9 @@ Example output of: `compile("tmp + 1").ast`
   constant: false }
 ```
 
-*NOTE* angular $parse do not export ast variable it's done by this library.
+_NOTE_ angular \$parse do not export ast variable it's done by this library.
 
-#### .compile.cache = {}
+#### .compile.cache = Object.create(null)
 
 A cache containing all compiled functions. The src is used as key. Set this on `false` to disable the cache.
 
@@ -122,34 +119,34 @@ The internal [Lexer](https://github.com/angular/angular.js/blob/6b049c74ccc9ee19
 
 The internal [Parser](https://github.com/angular/angular.js/blob/6b049c74ccc9ee19688bb9bbe504c300e61776dc/src/ng/parse.js#L390).
 
-----
+---
 
-### evaluate(scope?): *
+### evaluate(scope?): \*
 
 Evaluates the compiled `src` and returns the result of the expression. Property look-ups or assignments are executed on a given `scope`.
 
-### evaluate.assign(scope, value): *
+### evaluate.assign(scope, value): \*
 
 Tries to assign the given `value` to the result of the compiled expression on the given `scope` and returns the result of the assignment.
 
 
 
-In the browser
---------------
+## In the browser
 
 There is no `dist` build because it's not 2005 anymore. Use a module bundler like [webpack](http://webpack.github.io/) or [browserify](http://browserify.org/). They're both capable of CommonJS and AMD.
 
 
 
-Security
---------
+## Security
+
+The code of angular was not secured from reading prototype, and since version 1.0.1 of angular-expressions, the module disallows reading properties that are not ownProperties. See [this blog post](http://blog.angularjs.org/2016/09/angular-16-expression-sandbox-removal.html) for more details about the sandbox that got removed completely in angular 1.6.
 
 Comment from `angular.js/src/ng/parse.js`:
 
 ---
 
 Angular expressions are generally considered safe because these expressions only have direct
-access to $scope and locals. However, one can obtain the ability to execute arbitrary JS code by
+access to \$scope and locals. However, one can obtain the ability to execute arbitrary JS code by
 obtaining a reference to native JS functions such as the Function constructor.
 
 As an example, consider the following Angular expression:
@@ -180,16 +177,13 @@ window or some DOM object that has a reference to window is published onto a Sco
 
 
 
+## Authorship
 
-Authorship
-----------
 Kudos go entirely to the great angular.js team, it's their implementation!
 
-
 
 
-Contributing
-------------
+## Contributing
 
 Suggestions and bug-fixes are always appreciated. Don't hesitate to create an issue or pull-request. All contributed code should pass
 
@@ -198,12 +192,10 @@ Suggestions and bug-fixes are always appreciated. Don't hesitate to create an is
 
 
 
-License
--------
+## License
 
 [Unlicense](http://unlicense.org/)
 
-Sponsors
--------
+## Sponsors
 
 [](https://peerigon.com)
diff --git a/lib/main.js b/lib/main.js
index d8a12ed..10ed26a 100644
--- a/lib/main.js
+++ b/lib/main.js
@@ -6,24 +6,29 @@ var filters = {};
 var Lexer = parse.Lexer;
 var Parser = parse.Parser;
 var parserOptions = {
-    csp: false, // noUnsafeEval,
-    expensiveChecks: true,
-    literals: { // defined at: function $ParseProvider() {
-        true: true,
-        false: false,
-        null: null,
-        /*eslint no-undefined: 0*/
-        undefined: undefined
-        /* eslint: no-undefined: 1  */
-    }
-    //isIdentifierStart: undefined, //isFunction(identStart) && identStart,
-    //isIdentifierContinue: undefined //isFunction(identContinue) && identContinue
+	csp: false, // noUnsafeEval,
+	expensiveChecks: true,
+	literals: {
+		// defined at: function $ParseProvider() {
+		true: true,
+		false: false,
+		null: null,
+		/*eslint no-undefined: 0*/
+		undefined: undefined
+		/* eslint: no-undefined: 1  */
+	}
+	//isIdentifierStart: undefined, //isFunction(identStart) && identStart,
+	//isIdentifierContinue: undefined //isFunction(identContinue) && identContinue
 };
 
 var lexer = new Lexer({});
-var parser = new Parser(lexer, function getFilter(name) {
-    return filters[name];
-}, parserOptions);
+var parser = new Parser(
+	lexer,
+	function getFilter(name) {
+		return filters[name];
+	},
+	parserOptions
+);
 
 /**
  * Compiles src and returns a function that executes src on a target object.
@@ -33,22 +38,24 @@ var parser = new Parser(lexer, function getFilter(name) {
  * @returns {function}
  */
 function compile(src) {
-    var cached;
+	var cached;
 
-    if (typeof src !== "string") {
-        throw new TypeError("src must be a string, instead saw '" + typeof src + "'");
-    }
+	if (typeof src !== "string") {
+		throw new TypeError(
+			"src must be a string, instead saw '" + typeof src + "'"
+		);
+	}
 
-    if (!compile.cache) {
-        return parser.parse(src);
-    }
+	if (!compile.cache) {
+		return parser.parse(src);
+	}
 
-    cached = compile.cache[src];
-    if (!cached) {
-        cached = compile.cache[src] = parser.parse(src);
-    }
+	cached = compile.cache[src];
+	if (!cached) {
+		cached = compile.cache[src] = parser.parse(src);
+	}
 
-    return cached;
+	return cached;
 }
 
 /**
@@ -57,7 +64,7 @@ function compile(src) {
  *
  * @type {object}
  */
-compile.cache = {};
+compile.cache = Object.create(null);
 
 exports.Lexer = Lexer;
 exports.Parser = Parser;
diff --git a/lib/parse.js b/lib/parse.js
index 1c95915..e58ef56 100644
--- a/lib/parse.js
+++ b/lib/parse.js
@@ -34,11 +34,9 @@
 /*eslint no-multiple-empty-lines: 0*/
 /*eslint no-new: 0*/
 /*eslint no-unused-vars: 0*/
-'use strict';
+"use strict";
 
-var window = {document: {}};
-
-'use strict';
+var window = { document: {} };
 
 /* We need to tell ESLint what variables are being exported */
 /* exported
@@ -156,58 +154,83 @@ var window = {document: {}};
  * 
  */
 
+var NODE_TYPE_ELEMENT = 1;
+var NODE_TYPE_ATTRIBUTE = 2;
+var NODE_TYPE_TEXT = 3;
+var NODE_TYPE_COMMENT = 8;
+var NODE_TYPE_DOCUMENT = 9;
+var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
 var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
 
 // The name of a form control's ValidityState property.
 // This is used so that it's possible for internal tests to create mock ValidityStates.
-var VALIDITY_STATE_PROPERTY = 'validity';
+var VALIDITY_STATE_PROPERTY = "validity";
 
 var hasOwnProperty = Object.prototype.hasOwnProperty;
 
-var lowercase = function(string) {return isString(string) ? string.toLowerCase() : string;};
-var uppercase = function(string) {return isString(string) ? string.toUpperCase() : string;};
+var lowercase = function(string) {
+	return isString(string) ? string.toLowerCase() : string;
+};
+var uppercase = function(string) {
+	return isString(string) ? string.toUpperCase() : string;
+};
+
+/**
+ * @ngdoc function
+ * @name angular.isArray
+ * @module ng
+ * @kind function
+ *
+ * @description
+ * Determines if a reference is an `Array`.
+ *
+ * @param {*} value Reference to check.
+ * @returns {boolean} True if `value` is an `Array`.
+ */
+var isArray = Array.isArray;
 
+var ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"];
 
 var manualLowercase = function(s) {
-  /* eslint-disable no-bitwise */
-  return isString(s)
-      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
-      : s;
-  /* eslint-enable */
+	/* eslint-disable no-bitwise */
+	return isString(s)
+		? s.replace(/[A-Z]/g, function(ch) {
+				return String.fromCharCode(ch.charCodeAt(0) | 32);
+		  })
+		: s;
+	/* eslint-enable */
 };
 var manualUppercase = function(s) {
-  /* eslint-disable no-bitwise */
-  return isString(s)
-      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})
-      : s;
-  /* eslint-enable */
+	/* eslint-disable no-bitwise */
+	return isString(s)
+		? s.replace(/[a-z]/g, function(ch) {
+				return String.fromCharCode(ch.charCodeAt(0) & ~32);
+		  })
+		: s;
+	/* eslint-enable */
 };
 
-
 // String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish
 // locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
 // with correct but slower alternatives. See https://github.com/angular/angular.js/issues/11387
-if ('i' !== 'I'.toLowerCase()) {
-  lowercase = manualLowercase;
-  uppercase = manualUppercase;
+if ("i" !== "I".toLowerCase()) {
+	lowercase = manualLowercase;
+	uppercase = manualUppercase;
 }
 
-
-var
-    msie,             // holds major version number for IE, or NaN if UA is not IE.
-    jqLite,           // delay binding since jQuery could be loaded after us.
-    jQuery,           // delay binding
-    slice             = [].slice,
-    splice            = [].splice,
-    push              = [].push,
-    toString          = Object.prototype.toString,
-    getPrototypeOf    = Object.getPrototypeOf,
-    ngMinErr          = minErr('ng'),
-
-    /** @name angular */
-    angular           = window.angular || (window.angular = {}),
-    angularModule,
-    uid               = 0;
+var msie, // holds major version number for IE, or NaN if UA is not IE.
+	jqLite, // delay binding since jQuery could be loaded after us.
+	jQuery, // delay binding
+	slice = [].slice,
+	splice = [].splice,
+	push = [].push,
+	toString = Object.prototype.toString,
+	getPrototypeOf = Object.getPrototypeOf,
+	ngMinErr = minErr("ng"),
+	/** @name angular */
+	angular = window.angular || (window.angular = {}),
+	angularModule,
+	uid = 0;
 
 /**
  * documentMode is an IE-only property
@@ -215,7 +238,6 @@ var
  */
 msie = window.document.documentMode;
 
-
 /**
  * @private
  * @param {*} obj
@@ -223,25 +245,27 @@ msie = window.document.documentMode;
  *                   String ...)
  */
 function isArrayLike(obj) {
-
-  // `null`, `undefined` and `window` are not array-like
-  if (obj == null || isWindow(obj)) return false;
-
-  // arrays, strings and jQuery/jqLite objects are array like
-  // * jqLite is either the jQuery or jqLite constructor function
-  // * we have to check the existence of jqLite first as this method is called
-  //   via the forEach method when constructing the jqLite object in the first place
-  if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite)) return true;
-
-  // Support: iOS 8.2 (not reproducible in simulator)
-  // "length" in obj used to prevent JIT error (gh-11508)
-  var length = 'length' in Object(obj) && obj.length;
-
-  // NodeList objects (with `item` method) and
-  // other objects with suitable length characteristics are array-like
-  return isNumber(length) &&
-    (length >= 0 && ((length - 1) in obj || obj instanceof Array) || typeof obj.item === 'function');
-
+	// `null`, `undefined` and `window` are not array-like
+	if (obj == null || isWindow(obj)) return false;
+
+	// arrays, strings and jQuery/jqLite objects are array like
+	// * jqLite is either the jQuery or jqLite constructor function
+	// * we have to check the existence of jqLite first as this method is called
+	//   via the forEach method when constructing the jqLite object in the first place
+	if (isArray(obj) || isString(obj) || (jqLite && obj instanceof jqLite))
+		return true;
+
+	// Support: iOS 8.2 (not reproducible in simulator)
+	// "length" in obj used to prevent JIT error (gh-11508)
+	var length = "length" in Object(obj) && obj.length;
+
+	// NodeList objects (with `item` method) and
+	// other objects with suitable length characteristics are array-like
+	return (
+		isNumber(length) &&
+		((length >= 0 && (length - 1 in obj || obj instanceof Array)) ||
+			typeof obj.item === "function")
+	);
 }
 
 /**
@@ -280,63 +304,70 @@ function isArrayLike(obj) {
  */
 
 function forEach(obj, iterator, context) {
-  var key, length;
-  if (obj) {
-    if (isFunction(obj)) {
-      for (key in obj) {
-        if (key !== 'prototype' && key !== 'length' && key !== 'name' && obj.hasOwnProperty(key)) {
-          iterator.call(context, obj[key], key, obj);
-        }
-      }
-    } else if (isArray(obj) || isArrayLike(obj)) {
-      var isPrimitive = typeof obj !== 'object';
-      for (key = 0, length = obj.length; key < length; key++) {
-        if (isPrimitive || key in obj) {
-          iterator.call(context, obj[key], key, obj);
-        }
-      }
-    } else if (obj.forEach && obj.forEach !== forEach) {
-        obj.forEach(iterator, context, obj);
-    } else if (isBlankObject(obj)) {
-      // createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
-      for (key in obj) {
-        iterator.call(context, obj[key], key, obj);
-      }
-    } else if (typeof obj.hasOwnProperty === 'function') {
-      // Slow path for objects inheriting Object.prototype, hasOwnProperty check needed
-      for (key in obj) {
-        if (obj.hasOwnProperty(key)) {
-          iterator.call(context, obj[key], key, obj);
-        }
-      }
-    } else {
-      // Slow path for objects which do not have a method `hasOwnProperty`
-      for (key in obj) {
-        if (hasOwnProperty.call(obj, key)) {
-          iterator.call(context, obj[key], key, obj);
-        }
-      }
-    }
-  }
-  return obj;
+	var key, length;
+	if (obj) {
+		if (isFunction(obj)) {
+			for (key in obj) {
+				if (
+					key !== "prototype" &&
+					key !== "length" &&
+					key !== "name" &&
+					obj.hasOwnProperty(key)
+				) {
+					iterator.call(context, obj[key], key, obj);
+				}
+			}
+		} else if (isArray(obj) || isArrayLike(obj)) {
+			var isPrimitive = typeof obj !== "object";
+			for (key = 0, length = obj.length; key < length; key++) {
+				if (isPrimitive || key in obj) {
+					iterator.call(context, obj[key], key, obj);
+				}
+			}
+		} else if (obj.forEach && obj.forEach !== forEach) {
+			obj.forEach(iterator, context, obj);
+		} else if (isBlankObject(obj)) {
+			// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
+			// eslint-disable-next-line guard-for-in
+			for (key in obj) {
+				iterator.call(context, obj[key], key, obj);
+			}
+		} else if (typeof obj.hasOwnProperty === "function") {
+			// Slow path for objects inheriting Object.prototype, hasOwnProperty check needed
+			for (key in obj) {
+				if (obj.hasOwnProperty(key)) {
+					iterator.call(context, obj[key], key, obj);
+				}
+			}
+		} else {
+			// Slow path for objects which do not have a method `hasOwnProperty`
+			for (key in obj) {
+				if (hasOwnProperty.call(obj, key)) {
+					iterator.call(context, obj[key], key, obj);
+				}
+			}
+		}
+	}
+	return obj;
 }
 
 function forEachSorted(obj, iterator, context) {
-  var keys = Object.keys(obj).sort();
-  for (var i = 0; i < keys.length; i++) {
-    iterator.call(context, obj[keys[i]], keys[i]);
-  }
-  return keys;
+	var keys = Object.keys(obj).sort();
+	for (var i = 0; i < keys.length; i++) {
+		iterator.call(context, obj[keys[i]], keys[i]);
+	}
+	return keys;
 }
 
-
 /**
  * when using forEach the params are value, key, but it is often useful to have key, value.
  * @param {function(string, *)} iteratorFn
  * @returns {function(*, string)}
  */
 function reverseParams(iteratorFn) {
-  return function(value, key) {iteratorFn(key, value);};
+	return function(value, key) {
+		iteratorFn(key, value);
+	};
 }
 
 /**
@@ -350,56 +381,54 @@ function reverseParams(iteratorFn) {
  * @returns {number} an unique alpha-numeric string
  */
 function nextUid() {
-  return ++uid;
+	return ++uid;
 }
 
-
 /**
  * Set or clear the hashkey for an object.
  * @param obj object
  * @param h the hashkey (!truthy to delete the hashkey)
  */
 function setHashKey(obj, h) {
-  if (h) {
-    obj.$$hashKey = h;
-  } else {
-    delete obj.$$hashKey;
-  }
+	if (h) {
+		obj.$$hashKey = h;
+	} else {
+		delete obj.$$hashKey;
+	}
 }
 
-
 function baseExtend(dst, objs, deep) {
-  var h = dst.$$hashKey;
-
-  for (var i = 0, ii = objs.length; i < ii; ++i) {
-    var obj = objs[i];
-    if (!isObject(obj) && !isFunction(obj)) continue;
-    var keys = Object.keys(obj);
-    for (var j = 0, jj = keys.length; j < jj; j++) {
-      var key = keys[j];
-      var src = obj[key];
-
-      if (deep && isObject(src)) {
-        if (isDate(src)) {
-          dst[key] = new Date(src.valueOf());
-        } else if (isRegExp(src)) {
-          dst[key] = new RegExp(src);
-        } else if (src.nodeName) {
-          dst[key] = src.cloneNode(true);
-        } else if (isElement(src)) {
-          dst[key] = src.clone();
-        } else {
-          if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
-          baseExtend(dst[key], [src], true);
-        }
-      } else {
-        dst[key] = src;
-      }
-    }
-  }
-
-  setHashKey(dst, h);
-  return dst;
+	var h = dst.$$hashKey;
+
+	for (var i = 0, ii = objs.length; i < ii; ++i) {
+		var obj = objs[i];
+		if (!isObject(obj) && !isFunction(obj)) continue;
+		var keys = Object.keys(obj);
+		for (var j = 0, jj = keys.length; j < jj; j++) {
+			var key = keys[j];
+			var src = obj[key];
+
+			if (deep && isObject(src)) {
+				if (isDate(src)) {
+					dst[key] = new Date(src.valueOf());
+				} else if (isRegExp(src)) {
+					dst[key] = new RegExp(src);
+				} else if (src.nodeName) {
+					dst[key] = src.cloneNode(true);
+				} else if (isElement(src)) {
+					dst[key] = src.clone();
+				} else {
+					if (!isObject(dst[key])) dst[key] = isArray(src) ? [] : {};
+					baseExtend(dst[key], [src], true);
+				}
+			} else {
+				dst[key] = src;
+			}
+		}
+	}
+
+	setHashKey(dst, h);
+	return dst;
 }
 
 /**
@@ -421,46 +450,44 @@ function baseExtend(dst, objs, deep) {
  * @returns {Object} Reference to `dst`.
  */
 function extend(dst) {
-  return baseExtend(dst, slice.call(arguments, 1), false);
+	return baseExtend(dst, slice.call(arguments, 1), false);
 }
 
-
 /**
-* @ngdoc function
-* @name angular.merge
-* @module ng
-* @kind function
-*
-* @description
-* Deeply extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
-* to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
-* by passing an empty object as the target: `var object = angular.merge({}, object1, object2)`.
-*
-* Unlike {@link angular.extend extend()}, `merge()` recursively descends into object properties of source
-* objects, performing a deep copy.
-*
-* @param {Object} dst Destination object.
-* @param {...Object} src Source object(s).
-* @returns {Object} Reference to `dst`.
-*/
+ * @ngdoc function
+ * @name angular.merge
+ * @module ng
+ * @kind function
+ *
+ * @description
+ * Deeply extends the destination object `dst` by copying own enumerable properties from the `src` object(s)
+ * to `dst`. You can specify multiple `src` objects. If you want to preserve original objects, you can do so
+ * by passing an empty object as the target: `var object = angular.merge({}, object1, object2)`.
+ *
+ * Unlike {@link angular.extend extend()}, `merge()` recursively descends into object properties of source
+ * objects, performing a deep copy.
+ *
+ * @param {Object} dst Destination object.
+ * @param {...Object} src Source object(s).
+ * @returns {Object} Reference to `dst`.
+ */
 function merge(dst) {
-  return baseExtend(dst, slice.call(arguments, 1), true);
+	return baseExtend(dst, slice.call(arguments, 1), true);
 }
 
-
-
 function toInt(str) {
-  return parseInt(str, 10);
+	return parseInt(str, 10);
 }
 
-var isNumberNaN = Number.isNaN || function isNumberNaN(num) {
-  // eslint-disable-next-line no-self-compare
-  return num !== num;
-};
-
+var isNumberNaN =
+	Number.isNaN ||
+	function isNumberNaN(num) {
+		// eslint-disable-next-line no-self-compare
+		return num !== num;
+	};
 
 function inherit(parent, extra) {
-  return extend(Object.create(parent), extra);
+	return extend(Object.create(parent), extra);
 }
 
 /**
@@ -482,7 +509,6 @@ function inherit(parent, extra) {
 function noop() {}
 noop.$inject = [];
 
-
 /**
  * @ngdoc function
  * @name angular.identity
@@ -511,17 +537,21 @@ noop.$inject = [];
  * @param {*} value to be returned.
  * @returns {*} the value passed in.
  */
-function identity($) {return $;}
+function identity($) {
+	return $;
+}
 identity.$inject = [];
 
-
-function valueFn(value) {return function valueRef() {return value;};}
+function valueFn(value) {
+	return function valueRef() {
+		return value;
+	};
+}
 
 function hasCustomToString(obj) {
-  return isFunction(obj.toString) && obj.toString !== toString;
+	return isFunction(obj.toString) && obj.toString !== toString;
 }
 
-
 /**
  * @ngdoc function
  * @name angular.isUndefined
@@ -534,8 +564,9 @@ function hasCustomToString(obj) {
  * @param {*} value Reference to check.
  * @returns {boolean} True if `value` is undefined.
  */
-function isUndefined(value) {return typeof value === 'undefined';}
-
+function isUndefined(value) {
+	return typeof value === "undefined";
+}
 
 /**
  * @ngdoc function
@@ -549,8 +580,9 @@ function isUndefined(value) {return typeof value === 'undefined';}
  * @param {*} value Reference to check.
  * @returns {boolean} True if `value` is defined.
  */
-function isDefined(value) {return typeof value !== 'undefined';}
-
+function isDefined(value) {
+	return typeof value !== "undefined";
+}
 
 /**
  * @ngdoc function
@@ -566,21 +598,19 @@ function isDefined(value) {return typeof value !== 'undefined';}
  * @returns {boolean} True if `value` is an `Object` but not `null`.
  */
 function isObject(value) {
-  // http://jsperf.com/isobject4
-  return value !== null && typeof value === 'object';
+	// http://jsperf.com/isobject4
+	return value !== null && typeof value === "object";
 }
 
-
 /**
  * Determine if a value is an object with a null prototype
  *
  * @returns {boolean} True if `value` is an `Object` with a null prototype
  */
 function isBlankObject(value) {
-  return value !== null && typeof value === 'object' && !getPrototypeOf(value);
+	return value !== null && typeof value === "object" && !getPrototypeOf(value);
 }
 
-
 /**
  * @ngdoc function
  * @name angular.isString
@@ -593,8 +623,9 @@ function isBlankObject(value) {
  * @param {*} value Reference to check.
  * @returns {boolean} True if `value` is a `String`.
  */
-function isString(value) {return typeof value === 'string';}
-
+function isString(value) {
+	return typeof value === "string";
+}
 
 /**
  * @ngdoc function
@@ -614,8 +645,9 @@ function isString(value) {return typeof value === 'string';}
  * @param {*} value Reference to check.
  * @returns {boolean} True if `value` is a `Number`.
  */
-function isNumber(value) {return typeof value === 'number';}
-
+function isNumber(value) {
+	return typeof value === "number";
+}
 
 /**
  * @ngdoc function
@@ -630,24 +662,9 @@ function isNumber(value) {return typeof value === 'number';}
  * @returns {boolean} True if `value` is a `Date`.
  */
 function isDate(value) {
-  return toString.call(value) === '[object Date]';
+	return toString.call(value) === "[object Date]";
 }
 
-
-/**
- * @ngdoc function
- * @name angular.isArray
- * @module ng
- * @kind function
- *
- * @description
- * Determines if a reference is an `Array`.
- *
- * @param {*} value Reference to check.
- * @returns {boolean} True if `value` is an `Array`.
- */
-var isArray = Array.isArray;
-
 /**
  * @ngdoc function
  * @name angular.isFunction
@@ -660,8 +677,9 @@ var isArray = Array.isArray;
  * @param {*} value Reference to check.
  * @returns {boolean} True if `value` is a `Function`.
  */
-function isFunction(value) {return typeof value === 'function';}
-
+function isFunction(value) {
+	return typeof value === "function";
+}
 
 /**
  * Determines if a value is a regular expression object.
@@ -671,10 +689,9 @@ function isFunction(value) {return typeof value === 'function';}
  * @returns {boolean} True if `value` is a `RegExp`.
  */
 function isRegExp(value) {
-  return toString.call(value) === '[object RegExp]';
+	return toString.call(value) === "[object RegExp]";
 }
 
-
 /**
  * Checks if `obj` is a window object.
  *
@@ -683,65 +700,62 @@ function isRegExp(value) {
  * @returns {boolean} True if `obj` is a window obj.
  */
 function isWindow(obj) {
-  return obj && obj.window === obj;
+	return obj && obj.window === obj;
 }
 
-
 function isScope(obj) {
-  return obj && obj.$evalAsync && obj.$watch;
+	return obj && obj.$evalAsync && obj.$watch;
 }
 
-
 function isFile(obj) {
-  return toString.call(obj) === '[object File]';
+	return toString.call(obj) === "[object File]";
 }
 
-
 function isFormData(obj) {
-  return toString.call(obj) === '[object FormData]';
+	return toString.call(obj) === "[object FormData]";
 }
 
-
 function isBlob(obj) {
-  return toString.call(obj) === '[object Blob]';
+	return toString.call(obj) === "[object Blob]";
 }
 
-
 function isBoolean(value) {
-  return typeof value === 'boolean';
+	return typeof value === "boolean";
 }
 
-
 function isPromiseLike(obj) {
-  return obj && isFunction(obj.then);
+	return obj && isFunction(obj.then);
 }
 
-
 var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
 function isTypedArray(value) {
-  return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
+	return (
+		value &&
+		isNumber(value.length) &&
+		TYPED_ARRAY_REGEXP.test(toString.call(value))
+	);
 }
 
 function isArrayBuffer(obj) {
-  return toString.call(obj) === '[object ArrayBuffer]';
+	return toString.call(obj) === "[object ArrayBuffer]";
 }
 
-
 var trim = function(value) {
-  return isString(value) ? value.trim() : value;
+	return isString(value) ? value.trim() : value;
 };
 
 // Copied from:
 // http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1021
 // Prereq: s is a string.
 var escapeForRegexp = function(s) {
-  return s
-    .replace(/([-()\[\]{}+?*.$\^|,:#= 0) {
-    array.splice(index, 1);
-  }
-  return index;
+	var index = array.indexOf(value);
+	if (index >= 0) {
+		array.splice(index, 1);
+	}
+	return index;
 }
 
 /**
@@ -855,146 +872,161 @@ function arrayRemove(array, value) {
   
  */
 function copy(source, destination) {
-  var stackSource = [];
-  var stackDest = [];
-
-  if (destination) {
-    if (isTypedArray(destination) || isArrayBuffer(destination)) {
-      throw ngMinErr('cpta', 'Can\'t copy! TypedArray destination cannot be mutated.');
-    }
-    if (source === destination) {
-      throw ngMinErr('cpi', 'Can\'t copy! Source and destination are identical.');
-    }
-
-    // Empty the destination object
-    if (isArray(destination)) {
-      destination.length = 0;
-    } else {
-      forEach(destination, function(value, key) {
-        if (key !== '$$hashKey') {
-          delete destination[key];
-        }
-      });
-    }
-
-    stackSource.push(source);
-    stackDest.push(destination);
-    return copyRecurse(source, destination);
-  }
-
-  return copyElement(source);
-
-  function copyRecurse(source, destination) {
-    var h = destination.$$hashKey;
-    var key;
-    if (isArray(source)) {
-      for (var i = 0, ii = source.length; i < ii; i++) {
-        destination.push(copyElement(source[i]));
-      }
-    } else if (isBlankObject(source)) {
-      // createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
-      for (key in source) {
-        destination[key] = copyElement(source[key]);
-      }
-    } else if (source && typeof source.hasOwnProperty === 'function') {
-      // Slow path, which must rely on hasOwnProperty
-      for (key in source) {
-        if (source.hasOwnProperty(key)) {
-          destination[key] = copyElement(source[key]);
-        }
-      }
-    } else {
-      // Slowest path --- hasOwnProperty can't be called as a method
-      for (key in source) {
-        if (hasOwnProperty.call(source, key)) {
-          destination[key] = copyElement(source[key]);
-        }
-      }
-    }
-    setHashKey(destination, h);
-    return destination;
-  }
-
-  function copyElement(source) {
-    // Simple values
-    if (!isObject(source)) {
-      return source;
-    }
-
-    // Already copied values
-    var index = stackSource.indexOf(source);
-    if (index !== -1) {
-      return stackDest[index];
-    }
-
-    if (isWindow(source) || isScope(source)) {
-      throw ngMinErr('cpws',
-        'Can\'t copy! Making copies of Window or Scope instances is not supported.');
-    }
-
-    var needsRecurse = false;
-    var destination = copyType(source);
-
-    if (destination === undefined) {
-      destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
-      needsRecurse = true;
-    }
-
-    stackSource.push(source);
-    stackDest.push(destination);
-
-    return needsRecurse
-      ? copyRecurse(source, destination)
-      : destination;
-  }
-
-  function copyType(source) {
-    switch (toString.call(source)) {
-      case '[object Int8Array]':
-      case '[object Int16Array]':
-      case '[object Int32Array]':
-      case '[object Float32Array]':
-      case '[object Float64Array]':
-      case '[object Uint8Array]':
-      case '[object Uint8ClampedArray]':
-      case '[object Uint16Array]':
-      case '[object Uint32Array]':
-        return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);
-
-      case '[object ArrayBuffer]':
-        // Support: IE10
-        if (!source.slice) {
-          // If we're in this case we know the environment supports ArrayBuffer
-          /* eslint-disable no-undef */
-          var copied = new ArrayBuffer(source.byteLength);
-          new Uint8Array(copied).set(new Uint8Array(source));
-          /* eslint-enable */
-          return copied;
-        }
-        return source.slice(0);
-
-      case '[object Boolean]':
-      case '[object Number]':
-      case '[object String]':
-      case '[object Date]':
-        return new source.constructor(source.valueOf());
-
-      case '[object RegExp]':
-        var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
-        re.lastIndex = source.lastIndex;
-        return re;
-
-      case '[object Blob]':
-        return new source.constructor([source], {type: source.type});
-    }
-
-    if (isFunction(source.cloneNode)) {
-      return source.cloneNode(true);
-    }
-  }
+	var stackSource = [];
+	var stackDest = [];
+
+	if (destination) {
+		if (isTypedArray(destination) || isArrayBuffer(destination)) {
+			throw ngMinErr(
+				"cpta",
+				"Can't copy! TypedArray destination cannot be mutated."
+			);
+		}
+		if (source === destination) {
+			throw ngMinErr(
+				"cpi",
+				"Can't copy! Source and destination are identical."
+			);
+		}
+
+		// Empty the destination object
+		if (isArray(destination)) {
+			destination.length = 0;
+		} else {
+			forEach(destination, function(value, key) {
+				if (key !== "$$hashKey") {
+					delete destination[key];
+				}
+			});
+		}
+
+		stackSource.push(source);
+		stackDest.push(destination);
+		return copyRecurse(source, destination);
+	}
+
+	return copyElement(source);
+
+	function copyRecurse(source, destination) {
+		var h = destination.$$hashKey;
+		var key;
+		if (isArray(source)) {
+			for (var i = 0, ii = source.length; i < ii; i++) {
+				destination.push(copyElement(source[i]));
+			}
+		} else if (isBlankObject(source)) {
+			// createMap() fast path --- Safe to avoid hasOwnProperty check because prototype chain is empty
+			// eslint-disable-next-line guard-for-in
+			for (key in source) {
+				destination[key] = copyElement(source[key]);
+			}
+		} else if (source && typeof source.hasOwnProperty === "function") {
+			// Slow path, which must rely on hasOwnProperty
+			for (key in source) {
+				if (source.hasOwnProperty(key)) {
+					destination[key] = copyElement(source[key]);
+				}
+			}
+		} else {
+			// Slowest path --- hasOwnProperty can't be called as a method
+			for (key in source) {
+				if (hasOwnProperty.call(source, key)) {
+					destination[key] = copyElement(source[key]);
+				}
+			}
+		}
+		setHashKey(destination, h);
+		return destination;
+	}
+
+	function copyElement(source) {
+		// Simple values
+		if (!isObject(source)) {
+			return source;
+		}
+
+		// Already copied values
+		var index = stackSource.indexOf(source);
+		if (index !== -1) {
+			return stackDest[index];
+		}
+
+		if (isWindow(source) || isScope(source)) {
+			throw ngMinErr(
+				"cpws",
+				"Can't copy! Making copies of Window or Scope instances is not supported."
+			);
+		}
+
+		var needsRecurse = false;
+		var destination = copyType(source);
+
+		if (destination === undefined) {
+			destination = isArray(source)
+				? []
+				: Object.create(getPrototypeOf(source));
+			needsRecurse = true;
+		}
+
+		stackSource.push(source);
+		stackDest.push(destination);
+
+		return needsRecurse ? copyRecurse(source, destination) : destination;
+	}
+
+	function copyType(source) {
+		switch (toString.call(source)) {
+			case "[object Int8Array]":
+			case "[object Int16Array]":
+			case "[object Int32Array]":
+			case "[object Float32Array]":
+			case "[object Float64Array]":
+			case "[object Uint8Array]":
+			case "[object Uint8ClampedArray]":
+			case "[object Uint16Array]":
+			case "[object Uint32Array]":
+				return new source.constructor(
+					copyElement(source.buffer),
+					source.byteOffset,
+					source.length
+				);
+
+			case "[object ArrayBuffer]":
+				// Support: IE10
+				if (!source.slice) {
+					// If we're in this case we know the environment supports ArrayBuffer
+					/* eslint-disable no-undef */
+					var copied = new ArrayBuffer(source.byteLength);
+					new Uint8Array(copied).set(new Uint8Array(source));
+					/* eslint-enable */
+					return copied;
+				}
+				return source.slice(0);
+
+			case "[object Boolean]":
+			case "[object Number]":
+			case "[object String]":
+			case "[object Date]":
+				return new source.constructor(source.valueOf());
+
+			case "[object RegExp]":
+				var re = new RegExp(
+					source.source,
+					source.toString().match(/[^\/]*$/)[0]
+				);
+				re.lastIndex = source.lastIndex;
+				return re;
+
+			case "[object Blob]":
+				return new source.constructor([source], { type: source.type });
+		}
+
+		if (isFunction(source.cloneNode)) {
+			return source.cloneNode(true);
+		}
+	}
 }
 
-
 /**
  * @ngdoc function
  * @name angular.equals
@@ -1059,80 +1091,97 @@ function copy(source, destination) {
   
  */
 function equals(o1, o2) {
-  if (o1 === o2) return true;
-  if (o1 === null || o2 === null) return false;
-  // eslint-disable-next-line no-self-compare
-  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
-  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
-  if (t1 === t2 && t1 === 'object') {
-    if (isArray(o1)) {
-      if (!isArray(o2)) return false;
-      if ((length = o1.length) === o2.length) {
-        for (key = 0; key < length; key++) {
-          if (!equals(o1[key], o2[key])) return false;
-        }
-        return true;
-      }
-    } else if (isDate(o1)) {
-      if (!isDate(o2)) return false;
-      return equals(o1.getTime(), o2.getTime());
-    } else if (isRegExp(o1)) {
-      if (!isRegExp(o2)) return false;
-      return o1.toString() === o2.toString();
-    } else {
-      if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) ||
-        isArray(o2) || isDate(o2) || isRegExp(o2)) return false;
-      keySet = createMap();
-      for (key in o1) {
-        if (key.charAt(0) === '$' || isFunction(o1[key])) continue;
-        if (!equals(o1[key], o2[key])) return false;
-        keySet[key] = true;
-      }
-      for (key in o2) {
-        if (!(key in keySet) &&
-            key.charAt(0) !== '$' &&
-            isDefined(o2[key]) &&
-            !isFunction(o2[key])) return false;
-      }
-      return true;
-    }
-  }
-  return false;
+	if (o1 === o2) return true;
+	if (o1 === null || o2 === null) return false;
+	// eslint-disable-next-line no-self-compare
+	if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
+	var t1 = typeof o1,
+		t2 = typeof o2,
+		length,
+		key,
+		keySet;
+	if (t1 === t2 && t1 === "object") {
+		if (isArray(o1)) {
+			if (!isArray(o2)) return false;
+			if ((length = o1.length) === o2.length) {
+				for (key = 0; key < length; key++) {
+					if (!equals(o1[key], o2[key])) return false;
+				}
+				return true;
+			}
+		} else if (isDate(o1)) {
+			if (!isDate(o2)) return false;
+			return equals(o1.getTime(), o2.getTime());
+		} else if (isRegExp(o1)) {
+			if (!isRegExp(o2)) return false;
+			return o1.toString() === o2.toString();
+		} else {
+			if (
+				isScope(o1) ||
+				isScope(o2) ||
+				isWindow(o1) ||
+				isWindow(o2) ||
+				isArray(o2) ||
+				isDate(o2) ||
+				isRegExp(o2)
+			)
+				return false;
+			keySet = createMap();
+			for (key in o1) {
+				if (key.charAt(0) === "$" || isFunction(o1[key])) continue;
+				if (!equals(o1[key], o2[key])) return false;
+				keySet[key] = true;
+			}
+			for (key in o2) {
+				if (
+					!(key in keySet) &&
+					key.charAt(0) !== "$" &&
+					isDefined(o2[key]) &&
+					!isFunction(o2[key])
+				)
+					return false;
+			}
+			return true;
+		}
+	}
+	return false;
 }
 
 var csp = function() {
-  if (!isDefined(csp.rules)) {
-
-
-    var ngCspElement = (window.document.querySelector('[ng-csp]') ||
-                    window.document.querySelector('[data-ng-csp]'));
-
-    if (ngCspElement) {
-      var ngCspAttribute = ngCspElement.getAttribute('ng-csp') ||
-                    ngCspElement.getAttribute('data-ng-csp');
-      csp.rules = {
-        noUnsafeEval: !ngCspAttribute || (ngCspAttribute.indexOf('no-unsafe-eval') !== -1),
-        noInlineStyle: !ngCspAttribute || (ngCspAttribute.indexOf('no-inline-style') !== -1)
-      };
-    } else {
-      csp.rules = {
-        noUnsafeEval: noUnsafeEval(),
-        noInlineStyle: false
-      };
-    }
-  }
-
-  return csp.rules;
-
-  function noUnsafeEval() {
-    try {
-      // eslint-disable-next-line no-new, no-new-func
-      new Function('');
-      return false;
-    } catch (e) {
-      return true;
-    }
-  }
+	if (!isDefined(csp.rules)) {
+		var ngCspElement =
+			window.document.querySelector("[ng-csp]") ||
+			window.document.querySelector("[data-ng-csp]");
+
+		if (ngCspElement) {
+			var ngCspAttribute =
+				ngCspElement.getAttribute("ng-csp") ||
+				ngCspElement.getAttribute("data-ng-csp");
+			csp.rules = {
+				noUnsafeEval:
+					!ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1,
+				noInlineStyle:
+					!ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1
+			};
+		} else {
+			csp.rules = {
+				noUnsafeEval: noUnsafeEval(),
+				noInlineStyle: false
+			};
+		}
+	}
+
+	return csp.rules;
+
+	function noUnsafeEval() {
+		try {
+			// eslint-disable-next-line no-new, no-new-func
+			new Function("");
+			return false;
+		} catch (e) {
+			return true;
+		}
+	}
 };
 
 /**
@@ -1174,30 +1223,34 @@ var csp = function() {
  ```
  */
 var jq = function() {
-  if (isDefined(jq.name_)) return jq.name_;
-  var el;
-  var i, ii = ngAttrPrefixes.length, prefix, name;
-  for (i = 0; i < ii; ++i) {
-    prefix = ngAttrPrefixes[i];
-    el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]');
-    if (el) {
-      name = el.getAttribute(prefix + 'jq');
-      break;
-    }
-  }
-
-  return (jq.name_ = name);
+	if (isDefined(jq.name_)) return jq.name_;
+	var el;
+	var i,
+		ii = ngAttrPrefixes.length,
+		prefix,
+		name;
+	for (i = 0; i < ii; ++i) {
+		prefix = ngAttrPrefixes[i];
+		el = window.document.querySelector(
+			"[" + prefix.replace(":", "\\:") + "jq]"
+		);
+		if (el) {
+			name = el.getAttribute(prefix + "jq");
+			break;
+		}
+	}
+
+	return (jq.name_ = name);
 };
 
 function concat(array1, array2, index) {
-  return array1.concat(slice.call(array2, index));
+	return array1.concat(slice.call(array2, index));
 }
 
 function sliceArgs(args, startIndex) {
-  return slice.call(args, startIndex || 0);
+	return slice.call(args, startIndex || 0);
 }
 
-
 /**
  * @ngdoc function
  * @name angular.bind
@@ -1215,44 +1268,45 @@ function sliceArgs(args, startIndex) {
  * @param {...*} args Optional arguments to be prebound to the `fn` function call.
  * @returns {function()} Function that wraps the `fn` with all the specified bindings.
  */
+// eslint-disable-next-line consistent-this
 function bind(self, fn) {
-  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
-  if (isFunction(fn) && !(fn instanceof RegExp)) {
-    return curryArgs.length
-      ? function() {
-          return arguments.length
-            ? fn.apply(self, concat(curryArgs, arguments, 0))
-            : fn.apply(self, curryArgs);
-        }
-      : function() {
-          return arguments.length
-            ? fn.apply(self, arguments)
-            : fn.call(self);
-        };
-  } else {
-    // In IE, native methods are not functions so they cannot be bound (note: they don't need to be).
-    return fn;
-  }
+	var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
+	if (isFunction(fn) && !(fn instanceof RegExp)) {
+		return curryArgs.length
+			? function() {
+					return arguments.length
+						? fn.apply(self, concat(curryArgs, arguments, 0))
+						: fn.apply(self, curryArgs);
+			  }
+			: function() {
+					return arguments.length ? fn.apply(self, arguments) : fn.call(self);
+			  };
+	} else {
+		// In IE, native methods are not functions so they cannot be bound (note: they don't need to be).
+		return fn;
+	}
 }
 
-
 function toJsonReplacer(key, value) {
-  var val = value;
-
-  if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
-    val = undefined;
-  } else if (isWindow(value)) {
-    val = '$WINDOW';
-  } else if (value &&  window.document === value) {
-    val = '$DOCUMENT';
-  } else if (isScope(value)) {
-    val = '$SCOPE';
-  }
-
-  return val;
+	var val = value;
+
+	if (
+		typeof key === "string" &&
+		key.charAt(0) === "$" &&
+		key.charAt(1) === "$"
+	) {
+		val = undefined;
+	} else if (isWindow(value)) {
+		val = "$WINDOW";
+	} else if (value && window.document === value) {
+		val = "$DOCUMENT";
+	} else if (isScope(value)) {
+		val = "$SCOPE";
+	}
+
+	return val;
 }
 
-
 /**
  * @ngdoc function
  * @name angular.toJson
@@ -1290,14 +1344,13 @@ function toJsonReplacer(key, value) {
  * See https://github.com/angular/angular.js/pull/14221 for more information.
  */
 function toJson(obj, pretty) {
-  if (isUndefined(obj)) return undefined;
-  if (!isNumber(pretty)) {
-    pretty = pretty ? 2 : null;
-  }
-  return JSON.stringify(obj, toJsonReplacer, pretty);
+	if (isUndefined(obj)) return undefined;
+	if (!isNumber(pretty)) {
+		pretty = pretty ? 2 : null;
+	}
+	return JSON.stringify(obj, toJsonReplacer, pretty);
 }
 
-
 /**
  * @ngdoc function
  * @name angular.fromJson
@@ -1311,59 +1364,61 @@ function toJson(obj, pretty) {
  * @returns {Object|Array|string|number} Deserialized JSON string.
  */
 function fromJson(json) {
-  return isString(json)
-      ? JSON.parse(json)
-      : json;
+	return isString(json) ? JSON.parse(json) : json;
 }
 
-
 var ALL_COLONS = /:/g;
 function timezoneToOffset(timezone, fallback) {
-  // IE/Edge do not "understand" colon (`:`) in timezone
-  timezone = timezone.replace(ALL_COLONS, '');
-  var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
-  return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
+	// IE/Edge do not "understand" colon (`:`) in timezone
+	timezone = timezone.replace(ALL_COLONS, "");
+	var requestedTimezoneOffset =
+		Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 60000;
+	return isNumberNaN(requestedTimezoneOffset)
+		? fallback
+		: requestedTimezoneOffset;
 }
 
-
 function addDateMinutes(date, minutes) {
-  date = new Date(date.getTime());
-  date.setMinutes(date.getMinutes() + minutes);
-  return date;
+	date = new Date(date.getTime());
+	date.setMinutes(date.getMinutes() + minutes);
+	return date;
 }
 
-
 function convertTimezoneToLocal(date, timezone, reverse) {
-  reverse = reverse ? -1 : 1;
-  var dateTimezoneOffset = date.getTimezoneOffset();
-  var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
-  return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
+	reverse = reverse ? -1 : 1;
+	var dateTimezoneOffset = date.getTimezoneOffset();
+	var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
+	return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
 }
 
-
 /**
  * @returns {string} Returns the string representation of the element.
  */
 function startingTag(element) {
-  element = jqLite(element).clone();
-  try {
-    // turns out IE does not let you set .html() on elements which
-    // are not allowed to have children. So we just ignore it.
-    element.empty();
-  } catch (e) { /* empty */ }
-  var elemHtml = jqLite('').append(element).html();
-  try {
-    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) :
-        elemHtml.
-          match(/^(<[^>]+>)/)[1].
-          replace(/^<([\w\-]+)/, function(match, nodeName) {return '<' + lowercase(nodeName);});
-  } catch (e) {
-    return lowercase(elemHtml);
-  }
-
+	element = jqLite(element).clone();
+	try {
+		// turns out IE does not let you set .html() on elements which
+		// are not allowed to have children. So we just ignore it.
+		element.empty();
+	} catch (e) {
+		/* empty */
+	}
+	var elemHtml = jqLite("")
+		.append(element)
+		.html();
+	try {
+		return element[0].nodeType === NODE_TYPE_TEXT
+			? lowercase(elemHtml)
+			: elemHtml
+					.match(/^(<[^>]+>)/)[1]
+					.replace(/^<([\w\-]+)/, function(match, nodeName) {
+						return "<" + lowercase(nodeName);
+					});
+	} catch (e) {
+		return lowercase(elemHtml);
+	}
 }
 
-
 /////////////////////////////////////////////////
 
 /**
@@ -1375,62 +1430,64 @@ function startingTag(element) {
  * with the decodeURIComponent function.
  */
 function tryDecodeURIComponent(value) {
-  try {
-    return decodeURIComponent(value);
-  } catch (e) {
-    // Ignore any invalid uri component.
-  }
+	try {
+		return decodeURIComponent(value);
+	} catch (e) {
+		// Ignore any invalid uri component.
+	}
 }
 
-
 /**
  * Parses an escaped url query string into key-value pairs.
  * @returns {Object.}
  */
-function parseKeyValue(/**string*/keyValue) {
-  var obj = {};
-  forEach((keyValue || '').split('&'), function(keyValue) {
-    var splitPoint, key, val;
-    if (keyValue) {
-      key = keyValue = keyValue.replace(/\+/g,'%20');
-      splitPoint = keyValue.indexOf('=');
-      if (splitPoint !== -1) {
-        key = keyValue.substring(0, splitPoint);
-        val = keyValue.substring(splitPoint + 1);
-      }
-      key = tryDecodeURIComponent(key);
-      if (isDefined(key)) {
-        val = isDefined(val) ? tryDecodeURIComponent(val) : true;
-        if (!hasOwnProperty.call(obj, key)) {
-          obj[key] = val;
-        } else if (isArray(obj[key])) {
-          obj[key].push(val);
-        } else {
-          obj[key] = [obj[key],val];
-        }
-      }
-    }
-  });
-  return obj;
+function parseKeyValue(/**string*/ keyValue) {
+	var obj = {};
+	forEach((keyValue || "").split("&"), function(keyValue) {
+		var splitPoint, key, val;
+		if (keyValue) {
+			key = keyValue = keyValue.replace(/\+/g, "%20");
+			splitPoint = keyValue.indexOf("=");
+			if (splitPoint !== -1) {
+				key = keyValue.substring(0, splitPoint);
+				val = keyValue.substring(splitPoint + 1);
+			}
+			key = tryDecodeURIComponent(key);
+			if (isDefined(key)) {
+				val = isDefined(val) ? tryDecodeURIComponent(val) : true;
+				if (!hasOwnProperty.call(obj, key)) {
+					obj[key] = val;
+				} else if (isArray(obj[key])) {
+					obj[key].push(val);
+				} else {
+					obj[key] = [obj[key], val];
+				}
+			}
+		}
+	});
+	return obj;
 }
 
 function toKeyValue(obj) {
-  var parts = [];
-  forEach(obj, function(value, key) {
-    if (isArray(value)) {
-      forEach(value, function(arrayValue) {
-        parts.push(encodeUriQuery(key, true) +
-                   (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
-      });
-    } else {
-    parts.push(encodeUriQuery(key, true) +
-               (value === true ? '' : '=' + encodeUriQuery(value, true)));
-    }
-  });
-  return parts.length ? parts.join('&') : '';
+	var parts = [];
+	forEach(obj, function(value, key) {
+		if (isArray(value)) {
+			forEach(value, function(arrayValue) {
+				parts.push(
+					encodeUriQuery(key, true) +
+						(arrayValue === true ? "" : "=" + encodeUriQuery(arrayValue, true))
+				);
+			});
+		} else {
+			parts.push(
+				encodeUriQuery(key, true) +
+					(value === true ? "" : "=" + encodeUriQuery(value, true))
+			);
+		}
+	});
+	return parts.length ? parts.join("&") : "";
 }
 
-
 /**
  * We need our custom method because encodeURIComponent is too aggressive and doesn't follow
  * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
@@ -1443,13 +1500,12 @@ function toKeyValue(obj) {
  *                     / "*" / "+" / "," / ";" / "="
  */
 function encodeUriSegment(val) {
-  return encodeUriQuery(val, true).
-             replace(/%26/gi, '&').
-             replace(/%3D/gi, '=').
-             replace(/%2B/gi, '+');
+	return encodeUriQuery(val, true)
+		.replace(/%26/gi, "&")
+		.replace(/%3D/gi, "=")
+		.replace(/%2B/gi, "+");
 }
 
-
 /**
  * This method is intended for encoding *key* or *value* parts of query component. We need a custom
  * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be
@@ -1462,43 +1518,45 @@ function encodeUriSegment(val) {
  *                     / "*" / "+" / "," / ";" / "="
  */
 function encodeUriQuery(val, pctEncodeSpaces) {
-  return encodeURIComponent(val).
-             replace(/%40/gi, '@').
-             replace(/%3A/gi, ':').
-             replace(/%24/g, '$').
-             replace(/%2C/gi, ',').
-             replace(/%3B/gi, ';').
-             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));
+	return encodeURIComponent(val)
+		.replace(/%40/gi, "@")
+		.replace(/%3A/gi, ":")
+		.replace(/%24/g, "$")
+		.replace(/%2C/gi, ",")
+		.replace(/%3B/gi, ";")
+		.replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
 }
 
-var ngAttrPrefixes = ['ng-', 'data-ng-', 'ng:', 'x-ng-'];
-
 function getNgAttribute(element, ngAttr) {
-  var attr, i, ii = ngAttrPrefixes.length;
-  for (i = 0; i < ii; ++i) {
-    attr = ngAttrPrefixes[i] + ngAttr;
-    if (isString(attr = element.getAttribute(attr))) {
-      return attr;
-    }
-  }
-  return null;
+	var attr,
+		i,
+		ii = ngAttrPrefixes.length;
+	for (i = 0; i < ii; ++i) {
+		attr = ngAttrPrefixes[i] + ngAttr;
+		if (isString((attr = element.getAttribute(attr)))) {
+			return attr;
+		}
+	}
+	return null;
 }
 
 function allowAutoBootstrap(document) {
-  if (!document.currentScript) {
-    return true;
-  }
-  var src = document.currentScript.getAttribute('src');
-  var link = document.createElement('a');
-  link.href = src;
-  var scriptProtocol = link.protocol;
-  var docLoadProtocol = document.location.protocol;
-  if ((scriptProtocol === 'resource:' ||
-       scriptProtocol === 'chrome-extension:') &&
-      docLoadProtocol !== scriptProtocol) {
-    return false;
-  }
-  return true;
+	if (!document.currentScript) {
+		return true;
+	}
+	var src = document.currentScript.getAttribute("src");
+	var link = document.createElement("a");
+	link.href = src;
+	var scriptProtocol = link.protocol;
+	var docLoadProtocol = document.location.protocol;
+	if (
+		(scriptProtocol === "resource:" ||
+			scriptProtocol === "chrome-extension:") &&
+		docLoadProtocol !== scriptProtocol
+	) {
+		return false;
+	}
+	return true;
 }
 
 // Cached as it has to run during loading so that document.currentScript is available.
@@ -1639,37 +1697,42 @@ var isAutoBootstrapAllowed = allowAutoBootstrap(window.document);
  
  */
 function angularInit(element, bootstrap) {
-  var appElement,
-      module,
-      config = {};
-
-  // The element `element` has priority over any other element.
-  forEach(ngAttrPrefixes, function(prefix) {
-    var name = prefix + 'app';
-
-    if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
-      appElement = element;
-      module = element.getAttribute(name);
-    }
-  });
-  forEach(ngAttrPrefixes, function(prefix) {
-    var name = prefix + 'app';
-    var candidate;
-
-    if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
-      appElement = candidate;
-      module = candidate.getAttribute(name);
-    }
-  });
-  if (appElement) {
-    if (!isAutoBootstrapAllowed) {
-      window.console.error('Angular: disabling automatic bootstrap. 