3b96cb0293d3443b870351945f41d7d55cb34b53
nimble-platform@@common
diff --git a/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/common/DynamicName.java b/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/common/DynamicName.java
new file mode 100644
index 00000000..de05f110
--- /dev/null
+++ b/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/common/DynamicName.java
@@ -0,0 +1,44 @@
+package eu.nimble.service.model.solr.common;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.jena.ext.com.google.common.base.CaseFormat;
+import org.springframework.util.StringUtils;
+
+public interface DynamicName {
+	/**
+	 * Static (mixin) helper method transforming a qualifier into a valid dynamic field part
+	 * @param qualifier The qualifiers used when adding dynamic properties
+	 */
+	static String getDynamicFieldPart(String ... qualifier) {
+		List parts = new ArrayList<>();
+		for ( String part : qualifier ) {
+			parts.add(getDynamicFieldPart(part));
+		}
+		return getDynamicFieldPart(String.join("_", parts));
+
+		
+	}
+	/**
+	 * Static Helper for creating dynamic field parts where
+	 * non alphanumeric characters are deleted and whitespaces are 
+	 * replaces with underscores. Finally, the value is formatted
+	 * in CamelCase format starting with lower case.
+	 * As an example, the text "First Name" results in in a valid indexing name "firstName". 
+	 * @param part
+	 * @see CaseFormat#LOWER_CAMEL
+	 * @return
+	 */
+	static String getDynamicFieldPart(String part) {
+		if (! StringUtils.hasText(part)) {
+			// when no unit code specified - use "undefined";
+			return "undefined";
+		}		
+		String dynamicFieldPart = CaseFormat.UPPER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, part);
+		dynamicFieldPart = dynamicFieldPart.replaceAll("[^a-zA-Z0-9_ ]", "");
+		dynamicFieldPart = dynamicFieldPart.trim().replaceAll(" ", "_").toUpperCase();
+		dynamicFieldPart = CaseFormat.UPPER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, dynamicFieldPart);
+		return dynamicFieldPart;
+	}
+}
diff --git a/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/common/ICustomPropertyAware.java b/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/common/ICustomPropertyAware.java
new file mode 100644
index 00000000..3a0bebbd
--- /dev/null
+++ b/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/common/ICustomPropertyAware.java
@@ -0,0 +1,460 @@
+package eu.nimble.service.model.solr.common;
+
+import java.util.*;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import org.springframework.data.annotation.ReadOnlyProperty;
+import org.springframework.data.solr.core.mapping.SolrDocument;
+
+import eu.nimble.service.model.solr.owl.PropertyType;
+/**
+ * Interface providing the functionality for indexing arbitrary dynamic properties. A
+ * dynamic property is further qualified by key parts.
+ * 
+ * 
+ * Implementors inherit default functionality for handling dynamic properties. They may
+ * then add custom properties with 
+ * 
+ * addProperty(<value>, <qualifier 1>, ..., <qualifier n>)
+ * 
+ * where the provided qualifiers are used to create the dynamic key part for the value. 
+ * The kvalue is indexed depending on its type in the following fields:
+ * 
+ * String {@link #CUSTOM_STRING_PROPERTY}
+ * Integer {@link #CUSTOM_INTEGER_PROPERTY}
+ * Double {@link #CUSTOM_DOUBLE_PROPERTY}
+ * Boolean {@link #CUSTOM_BOOLEAN_PROPERTY}
+ * 
+ * with the key as dynamic filed part. 
+ * 
+ * The qualifiers are concatenated with @ as delimiter and stored in {@link #CUSTOM_KEY_FIELD}.
+ * The original qualifiers are also indexed in the {@link #CUSTOM_KEY_FIELD} for later retrieval:
+ * 
+ * get<type>PropertyValues(<qualifier 1>, ..., <qualifier n>)
+ * 
+ * will return again create the dynamic key an access the indexed values!
+ * 
+ * 
+ * A more concrete 
+ * example for indexing 
+ * 
+ * addProperty(3.14, "Rotation", "Max")
+ * 
+ * will first create the dynamic key (see {@link DynamicName#getDynamicFieldPart(String...)} for details) which 
+ * results in an eligible index field name part rotation_max. Since the provided value is a {@link Double} value, the resulting index field name will be
+ * rotation_max_ds.
+ * 
+ * For Retrieval, appropriate methods distinguish the type to return:
+ * 
+ * getDoublePropertyValues("Rotation", "Max")
+ * 
+ * will provide the stored values from the index field named rotation_max_ds.
+ * 
+ * @author dglachs
+ *
+ */
+public interface ICustomPropertyAware {
+	String getUri();
+	/**
+	 * Custom Property Key's including their label used
+	 */
+	String CUSTOM_KEY_FIELD = "*_key";
+	/**
+	 * The custom string properties field
+	 */
+	String CUSTOM_STRING_PROPERTY = "*_ss";
+	/**
+	 * The custom double properties field
+	 */
+	String CUSTOM_DOUBLE_PROPERTY = "*_ds";
+	/**
+	 * The custom integer properties field
+	 */
+	String CUSTOM_INTEGER_PROPERTY = "*_is";
+	/**
+	 * The custom boolean properties field
+	 */
+	String CUSTOM_BOOLEAN_PROPERTY = "*_b";
+	/**
+	 * Helper method to extract the collection
+	 * @return
+	 */
+	default String getCollection() {
+		SolrDocument solrDocument = getClass().getAnnotation(SolrDocument.class);
+		
+		if ( solrDocument != null && solrDocument.collection() != null) {
+			return solrDocument.collection();
+		}
+		throw new IllegalStateException("No @SolrDocument annotation found ...");
+	}
+
+	/**
+	 * Setter for a customized numeric value
+	 * @param value The double value
+	 * @param qualifier The dynamic name parts
+	 */
+	default void addProperty(Double value, String ... qualifier) {
+		addProperty(value, null, qualifier);
+
+	}
+	default void addProperty(Double value, PropertyType customMeta, String ... qualifier) {
+		String key = DynamicName.getDynamicFieldPart(qualifier);
+		// use @ as delimiter and store the original qualifier
+		getCustomPropertyKeys().put(key, String.join("@", qualifier));
+		// store the value
+		Collection values = getCustomDoubleValues().get(key);
+		if ( values == null ) {
+			// use a set to avoid duplicates
+			getCustomDoubleValues().put(key, new HashSet());
+		}
+		// now add the value to the double map
+		getCustomDoubleValues().get(key).add(value);
+		if ( customMeta !=null ) {
+			// handle custom property metadata
+			getCustomProperties().put(key, customMeta);
+		}
+	}
+	/**
+	 * Add a integer value to the index. The value is stored in the {@link #CUSTOM_INTEGER_PROPERTY}
+	 * field where the dynamic part of the is constructed on behalf of the qualifier.   
+	 * @param value The integer value
+	 * @param qualifier The dynamic field parts
+	 * @see DynamicName#getDynamicFieldPart(String...)
+	 */
+	default void addProperty(Integer value, String ... qualifier) {
+		addProperty(value, null, qualifier);
+	}
+	/**
+	 * Add a integer value to the index. The value is stored in the {@link #CUSTOM_INTEGER_PROPERTY}
+	 * field where the dynamic part of the is constructed on behalf of the qualifier.   
+	 * @param value The integer value to be added to the index
+	 * @param customMeta The custom property definition of the integer value
+	 * @param qualifier The dynamic field parts
+	 */
+	default void addProperty(Integer value, PropertyType customMeta, String ... qualifier) {
+		String key = DynamicName.getDynamicFieldPart(qualifier);
+		// use @ as delimiter and store the original qualifier
+		getCustomPropertyKeys().put(key, String.join("@", qualifier));
+		// store the value
+		Collection values = getCustomIntValues().get(key);
+		if ( values == null ) {
+			// use a set to avoid duplicates
+			getCustomIntValues().put(key, new HashSet());
+		}
+		// now add the value
+		getCustomIntValues().get(key).add(value);
+		if ( customMeta !=null ) {
+			// handle custom property metadata
+			getCustomProperties().put(key, customMeta);
+		}
+	}
+	/**
+	 * add a property (value)
+	 * @param value The value
+	 * @param qualifier The qualifier
+	 */
+	default void addProperty(String value, String ... qualifier) {
+		addProperty(value, (PropertyType)null, qualifier);
+	}
+	default void setProperties(Collection values, PropertyType customMeta, String...qualifier) {
+		// obtain the key
+		String key = DynamicName.getDynamicFieldPart(qualifier);
+		// use @ as delimiter and store the original qualifier
+		getCustomPropertyKeys().put(key, String.join("@", qualifier));
+		// use the first element for type detection
+		Optional first = values.stream().filter(Objects::nonNull).findFirst();
+		if ( first.isPresent() ) {
+			if ( first.get() instanceof String ) {
+				Collection strVal = values.stream().map(new Function() {
+
+					@Override
+					public String apply(Object t) {
+						return t.toString();
+					}
+				})
+				.collect(Collectors.toList());
+				getCustomStringValues().put(key, strVal);
+			}
+			if ( first.get() instanceof Integer) {
+				Collection intVal = values.stream().map(new Function() {
+
+					@Override
+					public Integer apply(Object t) {
+						return (Integer)t;
+					}
+				})
+				.collect(Collectors.toList());
+				getCustomIntValues().put(key, intVal);
+			}
+			if ( first.get() instanceof Double) {
+				Collection doubleVal = values.stream().map(new Function() {
+
+					@Override
+					public Double apply(Object t) {
+						return (Double)t;
+					}
+				})
+				.collect(Collectors.toList());
+				getCustomDoubleValues().put(key, doubleVal);
+			}
+			if ( first.get() instanceof Boolean) {
+				getCustomBooleanValue().put(key, (Boolean)first.get());
+			}
+			// maintain the custom property
+			if ( customMeta !=null ) {
+				// handle custom property metadata
+				getCustomProperties().put(key, customMeta);
+			}
+		}
+
+	
+	}
+	/**
+	 * Setter Method for for a dynamic property
+	 * @param values A collection holding values of either String, Integer, Double or Boolean values
+	 * @param qualifier
+	 */
+	default void setProperties(Collection values, String ...qualifier) {
+		setProperties(values, null, qualifier);
+	}
+	/**
+	 * Obtain the value of the qualified property of the requested type (assuming there 
+	 * is only one value stored, so the first value found is returned)
+	 * @param  String, Integer, Double or Boolean
+	 * @param clazz The type class
+	 * @param qualifier The qualifier used during indexing
+	 * @return The first value when present, {@link Optional#empty()} otherwise.
+	 */
+	default  Optional getProperty(Class clazz, String ...qualifier ) {
+		List coll = getProperties(clazz, qualifier);
+		if (! coll.isEmpty()) {
+			return Optional.of(coll.get(0));
+		}
+		return Optional.empty();
+	}
+	/**
+	 * Retrieve the (typesafe) collection of stored/indexed values. 
+	 * @param 
+	 * @param clazz The targeted class of the values (String, Double, Integer, Boolean)
+	 * @param qualifier The qualifier used during indexing
+	 * @return The collection of values, will not return null
+	 */
+	default  List getProperties(Class clazz, String ...qualifier) {
+		String key = DynamicName.getDynamicFieldPart(qualifier);
+		
+		if ( Integer.class.equals(clazz)) {
+			Collection is = getCustomIntValues().get(key);
+			if ( is != null && ! is.isEmpty()) {
+				return is.stream()
+						.map(new Function() {
+							public T apply(Integer i) {
+								return clazz.cast(i);
+							}
+							
+						})
+						.collect(Collectors.toList());
+			}
+		}
+		else if ( Double.class.equals(clazz)) {
+			Collection ds = getCustomDoubleValues().get(key);
+			if ( ds != null && ! ds.isEmpty()) {
+				return ds.stream()
+						.map(new Function() {
+							public T apply(Double d) {
+								return clazz.cast(d);
+							}
+							
+						})
+						.collect(Collectors.toList());
+			}
+		}
+		else if ( Boolean.class.equals(clazz)) {
+			Boolean b = getCustomBooleanValue().get(key);
+			if ( b != null) {
+				return Collections.singletonList(clazz.cast(b));
+			}
+		}
+		else {
+			Collection ss = getCustomStringValues().get(key);
+			if ( ss != null && ! ss.isEmpty()) {
+				return ss.stream()
+						.map(new Function() {
+							public T apply(String d) {
+								return clazz.cast(d);
+							}
+							
+						})
+						.collect(Collectors.toList());
+			}
+		}
+		return new ArrayList<>();
+	}
+	/**
+	 * Add a text property to the index
+	 * @param value the text value
+	 * @param customMeta The property metadata or null
+	 * @param qualifier the qualifier for storing in the index
+	 */
+	default void addProperty(String value, PropertyType customMeta, String ... qualifier) {
+		String key = DynamicName.getDynamicFieldPart(qualifier);
+		// use @ as delimiter and store the original qualifier
+		getCustomPropertyKeys().put(key, String.join("@", qualifier));
+		// store the value
+		Collection values = getCustomStringValues().get(key);
+		if ( values == null ) {
+			// use a set to avoid duplicates
+			getCustomStringValues().put(key, new HashSet());
+		}
+		// now add the value to the double map
+		getCustomStringValues().get(key).add(value);
+		if ( customMeta !=null ) {
+			// handle custom property metadata
+			getCustomProperties().put(key, customMeta);
+		}
+		
+	}
+	/**
+	 * Set a single custom string property
+	 * @param value
+	 * @param qualifier
+	 */
+	default void setProperty(String value, String ...qualifier ) {
+		setProperties(Collections.singletonList(value), null, qualifier);
+	}
+	/**
+	 * Set a single custom string property
+	 * @param value
+	 * @param meta
+	 * @param qualifier
+	 */
+	default void setProperty(String value, PropertyType meta, String ...qualifier ) {
+		setProperties(Collections.singletonList(value), meta, qualifier);
+	}
+	/**
+	 * Set a single custom integer property
+	 * @param value
+	 * @param qualifier
+	 */
+	default void setProperty(Integer value, String ...qualifier ) {
+		setProperties(Collections.singletonList(value), null, qualifier);
+	}
+	/**
+	 * Set a single custom integer property
+	 * @param value
+	 * @param qualifier
+	 */
+	default void setProperty(Integer value, PropertyType meta, String ...qualifier ) {
+		setProperties(Collections.singletonList(value), meta, qualifier);
+	}
+	/**
+	 * Set a single custom double property
+	 * @param value
+	 * @param qualifier
+	 */
+	default void setProperty(Double value, String ...qualifier ) {
+		setProperties(Collections.singletonList(value), null, qualifier);
+	}
+	/**
+	 * Set a single custom double property
+	 * @param value
+	 * @param qualifier
+	 */
+	default void setProperty(Double value, PropertyType meta, String ...qualifier ) {
+		setProperties(Collections.singletonList(value), meta, qualifier);
+	}
+	/**
+	 * Set a single custom boolean property
+	 * @param value
+	 * @param qualifier
+	 */
+	default void setProperty(Boolean value, String ...qualifier ) {
+		setProperties(Collections.singletonList(value), null, qualifier);
+	}
+	/**
+	 * Set a single custom boolean property
+	 * @param value
+	 * @param qualifier
+	 */
+	default void setProperty(Boolean value, PropertyType meta, String ...qualifier ) {
+		setProperties(Collections.singletonList(value), meta, qualifier);
+	}
+	
+//	/**
+//	 * Retrieve the collection of values - may be null
+//	 * @param qualifier
+//	 * @return
+//	 */
+//	default Collection getStringPropertyValues(String ... qualifier) {
+//		String key = DynamicName.getDynamicFieldPart(qualifier);
+//		return getCustomStringValues().get(key);
+//		
+//	}
+//	/**
+//	 * Setter for the string property values
+//	 * @param values
+//	 * @param qualifier The dynamic field part
+//	 */
+//	default void setStringPropertyValues(Collection values, String ...qualifier ) {
+//		String key = DynamicName.getDynamicFieldPart(qualifier);
+//		// use @ as delimiter and store the original qualifier
+//		getCustomPropertyKeys().put(key, String.join("@", qualifier));
+//		// store the collection
+//		getCustomStringValues().put(key, values);
+//	}
+//	default Optional getStringPropertyValue(String ...qualifier) {
+//		Collection v = getStringPropertyValues(qualifier);
+//		if ( v!=null ) {
+//			return v.stream().findFirst();
+//		}
+//		return Optional.empty();
+//	}
+//	default Collection getDoublePropertyValues(String ... qualifier) {
+//		String key = DynamicName.getDynamicFieldPart(qualifier);
+//		return getCustomDoubleValues().get(key);
+//	}
+//	/**
+//	 * Retrieve the integer values for the provided qualifiers
+//	 * @param qualifier The dynamic name parts
+//	 * @return
+//	 */
+//	default Collection getIntPropertyValues(String ... qualifier) {
+//		String key = DynamicName.getDynamicFieldPart(qualifier);
+//		return getCustomIntValues().get(key);
+//	}
+	
+	/**
+	 * Getter for the custom Integer values. Must not return null
+	 * @return
+	 */
+	public Map> getCustomIntValues();
+	/**
+	 * Getter for the custom double values. Must not return null
+	 * @return
+	 */
+	public Map> getCustomDoubleValues();
+	/**
+	 * Getter for the custom string values. Must not return null;
+	 * @return
+	 */
+	public Map> getCustomStringValues();
+	/**
+	 * Getter for the custom boolean values, must not return null
+	 * @return
+	 */
+	public Map getCustomBooleanValue();
+	/**
+	 * Getter for the custom property key map holding the original qualifier
+	 * and the mapped index field name part.
+	 * @return
+	 */
+	public Map getCustomPropertyKeys();
+	/**
+	 * Getter for the map holding the meta data for the custom 
+	 * property.
+	 * @return The custom property map, must not return null.
+	 */
+	@ReadOnlyProperty
+	public Map getCustomProperties();
+	
+}
diff --git a/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/owl/IConcept.java b/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/owl/IConcept.java
index 6725835a..63df4eef 100644
--- a/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/owl/IConcept.java
+++ b/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/owl/IConcept.java
@@ -4,6 +4,12 @@
 import java.util.Map;
 
 public interface IConcept {
+	String SOLR_STRING = "string";
+	String SOLR_NUMBER = "pdouble";
+	String SOLR_INT    = "pint";
+	String SOLR_BOOLEAN= "boolean";
+	
+	
 	String ID_FIELD = "id";
 	String CODE_FIELD = "code";
 	/**
diff --git a/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/party/PartyType.java b/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/party/PartyType.java
index f195a457..4e0bca49 100644
--- a/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/party/PartyType.java
+++ b/data-model/solr-data-model/src/main/java/eu/nimble/service/model/solr/party/PartyType.java
@@ -1,20 +1,27 @@
 package eu.nimble.service.model.solr.party;
 
-import java.util.*;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
 
 import org.apache.commons.lang3.StringUtils;
+import org.springframework.data.annotation.ReadOnlyProperty;
 import org.springframework.data.solr.core.mapping.Dynamic;
 import org.springframework.data.solr.core.mapping.Indexed;
 import org.springframework.data.solr.core.mapping.SolrDocument;
 
+import eu.nimble.service.model.solr.common.ICustomPropertyAware;
 import eu.nimble.service.model.solr.owl.Concept;
+import eu.nimble.service.model.solr.owl.PropertyType;
 /**
  * Class representing a manufacturer in the SOLR index
  * @author dglachs
  *
  */
 @SolrDocument(collection=IParty.COLLECTION)
-public class PartyType extends Concept implements IParty {
+public class PartyType extends Concept implements IParty, ICustomPropertyAware {
 
 //	@Indexed(name=NAME_FIELD)
 //	private String name;
@@ -75,6 +82,31 @@ public class PartyType extends Concept implements IParty {
 
 	@Indexed(name=WEBSITE_FIELD, type="string")
 	private String website;
+	
+	@Indexed(name=CUSTOM_INTEGER_PROPERTY, type=SOLR_INT)
+	@Dynamic
+	private Map> customIntValues;
+	@Indexed(name=CUSTOM_DOUBLE_PROPERTY, type=SOLR_NUMBER)
+	@Dynamic
+	private Map> customDoubleValues;
+	@Indexed(name=CUSTOM_STRING_PROPERTY, type=SOLR_STRING, copyTo = TEXT_FIELD)
+	@Dynamic
+	private Map> customStringValues;
+	@Indexed(name=CUSTOM_BOOLEAN_PROPERTY, type=SOLR_BOOLEAN)
+	@Dynamic
+	private Map customBooleanValue;
+	@Indexed(name=CUSTOM_KEY_FIELD, type=SOLR_STRING)
+	@Dynamic
+	private Map customPropertyKeys;
+	/**
+	 * 
+	 */
+	private Map customProperties;
+
+	@Override
+	public String getCollection() {
+		return IParty.COLLECTION;
+	}
 
 	public String getId() {
 		return getUri();
@@ -351,4 +383,47 @@ public String getWebsite() {
 	public void setWebsite(String website) {
 		this.website = website;
 	}
+	@Override
+	public Map> getCustomIntValues() {
+		if ( customIntValues == null ) {
+			customIntValues = new HashMap>();
+		}
+		return customIntValues;
+	}
+	@Override
+	public Map> getCustomDoubleValues() {
+		if (customDoubleValues == null) {
+			customDoubleValues = new HashMap>();
+		}
+		return customDoubleValues;
+	}
+	@Override
+	public Map> getCustomStringValues() {
+		if ( customStringValues == null) {
+			customStringValues = new HashMap>();
+		}
+		return customStringValues;
+	}
+	@Override
+	public Map getCustomBooleanValue() {
+		if ( customBooleanValue == null) {
+			customBooleanValue = new HashMap();
+		}
+		return customBooleanValue;
+	}
+	@Override
+	public Map getCustomPropertyKeys() {
+		if ( customPropertyKeys == null) {
+			customPropertyKeys = new HashMap();
+		}
+		return customPropertyKeys;
+	}
+	@Override
+	@ReadOnlyProperty
+	public Map getCustomProperties() {
+		if ( customProperties == null) {
+			customProperties = new HashMap();
+		}
+		return customProperties;
+	}
 }
diff --git a/utility/pom.xml b/utility/pom.xml
index 64e63d12..e11284e0 100644
--- a/utility/pom.xml
+++ b/utility/pom.xml
@@ -74,7 +74,7 @@
 		
com.fasterxml.jackson.core
jackson-databind
-			[2.8.11.3,)
+			2.12.3



