d44ca2308a96576b88d6bf27528964d4fe1a6b8b
roundcube@@roundcubemail
diff --git a/CHANGELOG b/CHANGELOG
index 88f10aaa23..47e34e7ee9 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -13,6 +13,8 @@ CHANGELOG Roundcube Webmail
 - Fix handling links without defined protocol (#7454)
 - Fix paging of search results on IMAP servers with no SORT capability (#7462)
 - Fix detecting special folders on servers with both SPECIAL-USE and LIST-STATUS (#7525)
+- Security: Fix cross-site scripting (XSS) via HTML messages with malicious svg content [CVE-2020-16145]
+- Security: Fix cross-site scripting (XSS) via HTML messages with malicious math content
 
 RELEASE 1.4.7
 -------------
diff --git a/program/lib/Roundcube/rcube_washtml.php b/program/lib/Roundcube/rcube_washtml.php
index fe91b02ac8..f2a8b04d0c 100644
--- a/program/lib/Roundcube/rcube_washtml.php
+++ b/program/lib/Roundcube/rcube_washtml.php
@@ -412,7 +412,30 @@ private function wash_uri($uri, $blocked_source = false, $is_image = true)
                 return $this->config['blocked_src'];
             }
         }
-        else if ($is_image && preg_match('/^data:image.+/i', $uri)) { // RFC2397
+        else if ($is_image && preg_match('/^data:image\/([^,]+),(.+)$/i', $uri, $matches)) { // RFC2397
+            // svg images can be insecure, we'll sanitize them
+            if (stripos($matches[1], 'svg') !== false) {
+                $svg = $matches[2];
+
+                if (stripos($matches[1], ';base64') !== false) {
+                    $svg  = base64_decode($svg);
+                    $type = $matches[1];
+                }
+                else {
+                    $type = $matches[1] . ';base64';
+                }
+
+                $washer = new self($this->config);
+                $svg    = $washer->wash($svg);
+
+                // Invalid svg content
+                if (empty($svg)) {
+                    return null;
+                }
+
+                return 'data:image/' . $type . ',' . base64_encode($svg);
+            }
+
             return $uri;
         }
     }
@@ -451,7 +474,7 @@ private function wash_link($href)
      */
     private function is_link_attribute($tag, $attr)
     {
-        return ($tag == 'a' || $tag == 'area') && $attr == 'href';
+        return $attr === 'href';
     }
 
     /**
@@ -468,6 +491,7 @@ private function is_image_attribute($tag, $attr)
             || $attr == 'color-profile' // SVG
             || ($attr == 'poster' && $tag == 'video')
             || ($attr == 'src' && preg_match('/^(img|image|source|input|video|audio)$/i', $tag))
+            || ($tag == 'use' && $attr == 'href') // SVG
             || ($tag == 'image' && $attr == 'href'); // SVG
     }
 
@@ -485,6 +509,31 @@ private function is_funciri_attribute($tag, $attr)
             'marker-end', 'marker-mid', 'clip-path', 'mask', 'cursor'));
     }
 
+    /**
+     * Check if a specified element has an attribute with specified value.
+     * Do it in case-insensitive manner.
+     *
+     * @param DOMElement $node       The element
+     * @param string     $attr_name  The attribute name
+     * @param string     $attr_value The attribute value to find
+     *
+     * @return bool True if the specified attribute exists and has the expected value
+     */
+    private static function attribute_value($node, $attr_name, $attr_value)
+    {
+        $attr_name = strtolower($attr_name);
+
+        foreach ($node->attributes as $name => $attr) {
+            if (strtolower($name) === $attr_name) {
+                if (strtolower($attr_value) === strtolower($attr->nodeValue)) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
     /**
      * The main loop that recurse on a node tree.
      * It output only allowed tags with allowed attributes and allowed inline styles
@@ -532,6 +581,13 @@ private function dumpHtml($node, $level = 20)
 
                     $node->setAttribute('href', (string) $uri);
                 }
+                else if (in_array($tagName, array('animate', 'animatecolor', 'set', 'animatetransform'))
+                    && self::attribute_value($node, 'attributename', 'href')
+                ) {
+                    // Insecure svg tags
+                    $dump .= "";
+                    break;
+                }
 
                 if ($callback = $this->handlers[$tagName]) {
                     $dump .= call_user_func($callback, $tagName,
diff --git a/tests/Framework/Washtml.php b/tests/Framework/Washtml.php
index 83e45c987d..c90ba61772 100644
--- a/tests/Framework/Washtml.php
+++ b/tests/Framework/Washtml.php
@@ -317,41 +317,166 @@ function test_wash_svg()
     }
 
     /**
-     * Test SVG cleanup
+     * Test cases for SVG tests
      */
-    function test_wash_svg2()
+    function data_wash_svg_tests()
     {
-        $svg = '';
-        $exp = '';
-
-        $washer = new rcube_washtml;
-        $washed = $washer->wash($svg);
-
-        $this->assertSame($washed, $exp, "SVG content");
-
-        $svg = 'Hello victim!';
-        $exp = 'Hello victim!';
-
-        $washer = new rcube_washtml;
-        $washed = $washer->wash($svg);
-
-        $this->assertSame($washed, $exp, "SVG content");
-
-        $svg = 'Hello victim!';
-        $exp = 'Hello victim!';
+        $svg1 = "";
+
+        return [
+            [
+                '',
+                ''
+            ],
+            [
+                'Hello victim!',
+                'Hello victim!'
+            ],
+            [
+                'Hello victim!',
+                'Hello victim!'
+            ],
+            [
+                'Hello victim!',
+                'Hello victim!'
+            ],
+            [
+                '',
+                ''
+            ],
+            [
+                '',
+                ''
+            ],
+            [
+                'XSS',
+                'XSS'
+            ],
+            [
+                'XSS',
+                'XSS'
+            ],
+            [
+                ''
+                    . 'XSS',
+                'XSS',
+            ],
+            [
+                ''
+                    . 'XSS',
+                ''
+                    . 'XSS',
+            ],
+            [
+                ''
+                    . 'XSS',
+                'XSS',
+            ],
+            [
+                ''
+                    . 'XSS',
+                'XSS',
+            ],
+            [
+                ''
+                    . 'XSS',
+                'XSS',
+            ],
+            [
+                "",
+                ""
+            ],
+            [
+                "",
+                ""
+            ],
+            [
+                'XSS',
+                'XSS'
+            ],
+        ];
+    }
 
+    /**
+     * Test SVG cleanup
+     *
+     * @dataProvider data_wash_svg_tests
+     */
+    function test_wash_svg_tests($input, $expected)
+    {
         $washer = new rcube_washtml;
-        $washed = $washer->wash($svg);
+        $washed = $washer->wash($input);
 
-        $this->assertSame($washed, $exp, "SVG content");
+        $this->assertSame($expected, $washed, "SVG content");
+    }
 
-        $svg = '';
-        $exp = '';
+    /**
+     * Test cases for various XSS issues
+     */
+    function data_wash_xss_tests()
+    {
+        return [
+            [
+                'test',
+                'test'
+            ],
+            [
+                'blah',
+                'blah'
+            ],
+            [
+                'XSS',
+                'XSS'
+            ],
+            [
+                'XSS',
+                'XSS'
+            ],
+            [
+                'XSS',
+                'XSS'
+            ],
+            [
+                '',
+                ''
+            ],
+            [
+                'clickme',
+                'clickme',
+            ],
+            [
+                'clickme',
+                'clickme',
+            ],
+            [
+                'clickme',
+                'clickme',
+            ],
+            [
+                'clickme',
+                'clickme',
+            ],
+        ];
+    }
 
-        $washer = new rcube_washtml;
-        $washed = $washer->wash($svg);
+    /**
+     * Test various XSS issues
+     *
+     * @dataProvider data_wash_xss_tests
+     */
+    function test_wash_xss_tests($input, $expected)
+    {
+        $washer = new rcube_washtml(['allow_remote' => true, 'html_elements' => ['body']]);
+        $washed = $washer->wash($input);
 
-        $this->assertSame($washed, $exp, "SVG content");
+        $this->assertSame($expected, $washed, "XSS issues");
     }
 
     /**
